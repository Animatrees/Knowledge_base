Способы кэширования

Кэширование на уровне сайта

Кэширование на уровне представлений

Кэширование на уровне шаблонов

Низкоуровневое кэширование с использованием API

Про Redis подробнее

Установка Redis на Linux

Подключение Redis к Django проекту

## Способы кэширования

### Кэширование на уровне сайта

Когда мы говорим о кэшировании на уровне сайта, это подразумевает, что весь HTML-контент страницы кэшируется и сохраняется с помощью выбранного бэкенда кэширования. При повторном обращении к этой странице, сервер возвращает кэшированную версию без повторного выполнения логики представления и без обращения к базе данных. Это позволяет значительно снизить нагрузку на сервер.

**Когда использовать:**

Кэширование на уровне сайта может быть полезно, если оно применяется к страницам, которые редко меняются и могут быть одинаковыми для всех пользователей. Однако, в реальных проектах редко бывает, что все страницы удовлетворяют этим критериям. Именно поэтому часто комбинируют подходы: основное кэширование на уровне сайта для большинства страниц, и более точная настройка для страниц, которые должны обновляться чаще или содержат пользовательские данные.

**Описание алгоритма реализации:**

В `**settings.py**`**:**

```Python
MIDDLEWARE = [
		'debug_toolbar.middleware.DebugToolbarMiddleware',
		...,
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.cache.FetchCacheMiddleware',
    ...,
]

CACHE_MIDDLEWARE_ALIAS = "default"
CACHE_MIDDLEWARE_SECONDS = 600  # 10 минут
CACHE_MIDDLEWARE_KEY_PREFIX = ""
```

Middleware `UpdateCacheMiddleware` и `FetchCacheMiddleware` кэшируют все страницы сайта по умолчанию. Если вы хотите исключить определенные страницы или условия, это можно настроить дополнительно.

Например, декораторы `cache_control()` и `never_cache()` можно использовать в данном подходе для более тонкой настройки кэширования отдельных представлений:

- `cache_control()` позволяет тонко настроить поведение кэширования, устанавливая различные параметры и условия для кэша.
- `never_cache()` полностью отключает кэширование для определенного представления, гарантируя, что ответ всегда будет актуальным и свежим.

Если нужно исключить больше страниц или установить более сложные условия, можно создать собственный middleware.

**Константы CACHE_MIDDLEWARE:**

- **CACHE_MIDDLEWARE_ALIAS:** Указывает, какой кэш использовать (по умолчанию "default").
- **CACHE_MIDDLEWARE_SECONDS:** Определяет время жизни кэша для страниц в секундах.
- **CACHE_MIDDLEWARE_KEY_PREFIX:** Позволяет задать префикс для ключей кэша, чтобы избежать конфликтов с другими кэшами.

### Кэширование на уровне представлений

Кэширование на уровне представлений позволяет кэшировать результаты выполнения конкретных представлений (views), что особенно полезно для страниц, которые могут содержать динамические данные или часто запрашиваемую информацию. Это позволяет снизить нагрузку на сервер и базу данных, повторно используя ранее сгенерированные данные.

**Когда использовать:**

Кэширование на уровне представлений целесообразно использовать для:

- Страниц, которые генерируют динамическое содержимое, но не меняются слишком часто.
- Представлений, выполняющих тяжелые запросы к базе данных.
- Представлений, которые содержат данные, общие для многих пользователей.

**Описание алгоритма реализации:**

В Django для кэширования представлений можно использовать декоратор `cache_page`. Этот декоратор кэширует результат выполнения представления на заданное время.

**Пример использования декоратора** `**cache_page**`**:**

В `**views.py**`**:**

```Python
from django.views.decorators.cache import cache_page
from django.shortcuts import render

@cache_page(60 * 15)  # Кэширование на 15 минут
def my_view(request):
    # код вашего представления
    return render(request, 'my_template.html', context)
```

**Параметры декоратора** `**cache_page**`**:**

- **timeout:** Время в секундах, в течение которого ответ будет храниться в кэше. В данном примере это 15 минут (60 секунд * 15).
- **cache:** (необязательный) Имя кэша, если у вас несколько конфигураций кэша. По умолчанию используется кэш, указанный в `CACHE_MIDDLEWARE_ALIAS`.
- **key_prefix:** (необязательный) Префикс для ключей кэша, чтобы избежать конфликтов с другими кэшированными данными.

Для использования с классом представления, нужно декорировать класс в URL маршруте:

```Python
from django.views.decorators.cache import cache_page

urlpatterns = [
    path("foo/<int:code>/", cache_page(60 * 15)(my_view)),
]
```

### Кэширование на уровне шаблонов

Кэширование на уровне шаблонов предполагает кэширование отдельных фрагментов шаблонов. Это позволяет уменьшить количество вычислений и обращений к базе данных при рендеринге страницы, сохраняя часто используемые и редко меняющиеся части шаблона.

**Когда использовать:**

Кэширование на уровне шаблонов целесообразно использовать для:

- Часто используемых фрагментов страницы, таких как боковые панели, баннеры, меню навигации.
- Данных, которые редко меняются, например, списки категорий, популярные товары.
- Фрагментов страницы, которые требуют сложных вычислений или частых запросов к базе данных.

**Описание алгоритма реализации:**

В Django для кэширования шаблонов используется тег `{% cache %}`.

В `template.html`:

```HTML
{% load cache %}

<!-- Кэшируем фрагмент шаблона на 15 минут -->
{% cache 900 sidebar user.username %}
    <div class="sidebar">
        <!-- код для боковой панели -->
        {% for category in categories %}
            <a href="{{ category.get_absolute_url }}">{{ category.name }}</a>
        {% endfor %}
    </div>
{% endcache %}
```

**Константы и параметры:**

- **timeout:** Время жизни кэша для фрагмента в секундах (в примере 900).
- **key:** Именованный ключ для кэширования фрагмента, чтобы избежать конфликтов с другими кэшированными данными (в примере sidebar).
- **additional arguments:** динамические переменные, которые будут обновляться для кэшированного фрагмента.

> [!important]  
> При использовании этого и предыдущего подхода можно использовать комбинацию со следующим подходом для обновления данных в кэше по какому-то условию)  

### Низкоуровневое кэширование с использованием API

Низкоуровневое кэширование позволяет программистам точно контролировать, что и когда кэшировать, используя API для работы с кэшем. Это наиболее гибкий подход, который позволяет кэшировать любые данные, включая результаты сложных вычислений, выборки из базы данных или ответы API.

**Когда использовать:**

Низкоуровневое кэширование целесообразно использовать для:

- Кэширования специфичных данных, которые не покрываются стандартными методами.
- Сложных вычислений, результаты которых можно повторно использовать.
- Оптимизации производительности в узких местах приложения.
- Кэширования данных, которые обновляются по специфическим условиям.

**Описание алгоритма реализации:**

В Django для низкоуровневого кэширования используется API, предоставляемое модулем `django.core.cache`.

**Пример использования:**

В `**views.py**`**:**

```Python
from django.core.cache import cache
from django.shortcuts import render
from .models import MyModel

def my_view(request):
    # Определяем ключ кэша
    cache_key = 'my_view_data'

    # Проверяем, есть ли данные в кэше
    data = cache.get(cache_key)

    if not data:
        # Если данных нет, получаем их из базы данных
        data = MyModel.objects.all()
        # Сохраняем данные в кэш на 15 минут
        cache.set(cache_key, data, 60 * 15)

    return render(request, 'my_template.html', {'data': data})
```

**Методы для работы с API:**

- `cache.set(key, value, timeout=`_`DEFAULT_TIMEOUT`_`, version=None)`
    
    Сохраняет значение в кэш по указанному ключу.
    
    **Аргументы:**
    
    - `key`: Ключ для сохранения значения.
    - `value`: Значение для сохранения.
    - `timeout`: Время жизни кэша в секундах (Если не указано, используется значение по умолчанию, заданное в настройках кэша).
    - `version`: Версия кэша (по умолчанию — None).
- `cache.get(key, default=None, version=None)`
    
    Извлекает значение из кэша по указанному ключу.  
      
    **Аргументы:**
    
    - `key`: Ключ для извлечения значения.
    - `default`: Значение по умолчанию, если ключ не найден (по умолчанию — None).
    - `version`: Версия кэша (по умолчанию — None).
- `cache.add(key, value, timeout=`_`DEFAULT_TIMEOUT`_`, version=None)`
    
    Сохраняет значение в кэш, если ключ ещё не существует.  
      
    **Аргументы:**
    
    - `key`: Ключ для сохранения значения.
    - `value`: Значение для сохранения.
    - `timeout`: Время жизни кэша в секундах (Если не указано, используется значение по умолчанию, заданное в настройках кэша).
    - `version`: Версия кэша (по умолчанию — None).
- `cache.get_or_set(key, default, timeout=`_`DEFAULT_TIMEOUT`_`, version=None)`
    
    Возвращает значение из кэша по ключу или сохраняет и возвращает значение, если ключ не найден.  
      
    **Аргументы:**
    
    - `key`: Ключ для извлечения или сохранения значения.
    - `default`: Значение для сохранения и возвращения, если ключ не найден. В том числе можно использовать `callable` в качестве значения по умолчанию.
    - `timeout`: Время жизни кэша в секундах (Если не указано, используется значение по умолчанию, заданное в настройках кэша).
    - `version`: Версия кэша (по умолчанию — None).
- `cache.delete(key, version=None)`
    
    Удаляет значение из кэша по указанному ключу.  
      
    **Аргументы:**
    
    - `key`: Ключ для удаления значения.
    - `version`: Версия кэша (по умолчанию — None).
- `cache.clear()`
    
    Очищает весь кэш.  
      
    **Аргументы:** Аргументы не требуются.
    
    - Доп. методы
        - `cache.get_many(keys, version=None)`
            
            Извлекает значения из кэша по указанным ключам.  
              
            **Аргументы:**
            
            - `keys`: Список ключей для извлечения значений.
            - `version`: Версия кэша (по умолчанию — None).
        - `cache.set_many(dict, timeout)`
            
            Сохраняет множество значений в кэш.  
              
            **Аргументы:**
            
            - `dict`: Словарь, где ключи — это ключи кэша, а значения — сохраняемые значения.
            - `timeout`: Время жизни кэша в секундах.
        - `cache.delete_many(keys, version=None)`
            
            Удаляет множество значений из кэша по указанным ключам.  
              
            **Аргументы:**
            
            - `keys`: Список ключей для удаления значений.
            - `version`: Версия кэша (по умолчанию — None).
        - `cache.touch(key, timeout=DEFAULT_TIMEOUT, version=None)`
            
            Обновляет время жизни указанного значения в кэше.  
              
            **Аргументы:**
            
            - `key`: Ключ для обновления времени жизни.
            - `timeout`: Новое время жизни кэша в секундах (по умолчанию — `DEFAULT_TIMEOUT`).
            - `version`: Версия кэша (по умолчанию — None).
        - `cache.incr(key, delta=1, version=None)`
            
            Увеличивает числовое значение в кэше на указанное значение (по умолчанию — на 1).  
              
            **Аргументы:**
            
            - `key`: Ключ для увеличения значения.
            - `delta`: Величина увеличения (по умолчанию — 1).
            - `version`: Версия кэша (по умолчанию — None).
        - `cache.decr(key, delta=1, version=None)`
            
            Уменьшает числовое значение в кэше на указанное значение (по умолчанию — на 1).  
              
            **Аргументы:**
            
            - `key`: Ключ для уменьшения значения.
            - `delta`: Величина уменьшения (по умолчанию — 1).
            - `version`: Версия кэша (по умолчанию — None).
        - `cache.close()`
            
            Закрывает соединение с кэшем.  
              
            **Аргументы:** Аргументы не требуются.
            
              
            

## Про Redis подробнее

**Redis** — это высокопроизводительное хранилище данных типа "ключ-значение", которое использует оперативную память для хранения данных. Это позволяет Redis обеспечивать очень быструю скорость чтения и записи данных. В отличие от традиционных баз данных, которые сохраняют данные на диске, Redis хранит все данные в оперативной памяти, что делает его чрезвычайно быстрым и подходящим для задач, требующих минимальной задержки.

В основе работы Redis лежит модель клиент-сервер, где клиенты отправляют команды серверу, который обрабатывает их и возвращает результаты. Redis поддерживает множество типов данных, включая строки, списки, множества, отсортированные множества, хэши, битмапы и гиперлоги. Эта поддержка различных структур данных позволяет Redis быть очень гибким и использоваться для широкого спектра задач, таких как кэширование, управление сессиями, отслеживание статистики и многое другое.

Помимо работы с данными в памяти, Redis поддерживает механизмы сохранения данных на диск для обеспечения их сохранности при перезагрузке или сбое системы. Это достигается с помощью механизмов snapshotting и журнала транзакций (AOF - Append Only File). Snapshotting периодически создает полные копии данных на диск, а AOF записывает каждую операцию изменения данных в журнал, который можно использовать для восстановления состояния базы данных при запуске.

Redis также поддерживает репликацию, что позволяет создавать копии данных на нескольких серверах для обеспечения отказоустойчивости и повышения доступности. Кластеризация в Redis позволяет разделить данные между несколькими узлами, что улучшает масштабируемость и производительность системы.

Таким образом, Redis сочетает в себе высокую производительность in-memory хранения данных с гибкостью поддержки различных типов данных и надежностью благодаря механизмам сохранения и репликации данных. Это делает его мощным инструментом для разработки высоконагруженных приложений.

[Документация](https://redis.io/).

## Установка Redis на Linux

Если вы используете очень минимальный дистрибутив Linux, например, Docker контейнер, где многие стандартные утилиты могут быть изначально не установлены, вам нужно предварительно выполнить следующую команду:

```Shell
sudo apt install lsb-release curl gpg
```

1. `lsb-release`: Эта утилита используется для получения информации о версии операционной системы, которая необходима для корректного определения кода имени дистрибутива (например, `noble` для Ubuntu 24.04). Без этой утилиты команда `$(lsb_release -cs)` не сможет вернуть необходимую информацию.
2. `curl`: Эта утилита используется для загрузки данных с веб-серверов, в данном случае, для загрузки GPG ключа Redis. Если `curl` не установлен, команда загрузки ключа не выполнится.
3. `gpg`: Эта утилита необходима для работы с GPG ключами, включая их преобразование и сохранение. Без `gpg` команда преобразования и сохранения ключа не сможет выполниться.

Чтобы проверить есть ли данные пакеты в системе, используем следующую команду:

```Shell
dpkg -l | grep -E "lsb-release|curl|gpg"
```

Если пакеты установлены, вы увидите их в выводе команды. Если какой-то из них отсутствует, его нужно будет установить перед выполнением команд, связанных с установкой Redis.

**Команды для установки Redis**

```Shell
curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list

sudo apt-get update
sudo apt-get install redis
```

Описание команд:

1. Загружает и сохраняет ключ GPG для подписанных пакетов Redis, чтобы система могла проверить их подлинность.
2. Добавляет внешний репозиторий Redis в список источников APT на вашей системе. Репозиторий будет использован для установки и обновления пакетов Redis.
3. Обновляет локальный кэш списка пакетов, чтобы система знала о новых пакетах, доступных из добавленного репозитория Redis.
4. Устанавливает сервер Redis на вашу систему из добавленного внешнего репозитория.

**Для запуска Redis выполняем команду:**

```Shell
sudo service redis-server start
```

Чтобы проверить, что всё работает:

```Shell
~ redis-cli
127.0.0.1:6379> ping
```

В ответ должны получить:

![[Untitled 19.png|Untitled 19.png]]

Для выхода из оболочки redis - ctrl + c.

Для остановки сервера `sudo service redis-server stop`

## Подключение Redis к Django проекту

1. В виртуальное окружение проекта устанавливаем следующие пакеты:
    
    ```Shell
    pip install redis
    pip install hiredis
    ```
    
2. В `settings.py` прописываем настройку для бэкенда:
    
    ```Python
    CACHES = {
        "default": {
            "BACKEND": "django.core.cache.backends.redis.RedisCache",
            "LOCATION": "redis://127.0.0.1:6379",
        }
    }
    ```
    

После подключения Redis-а можно использовать любой из способов кэширования, описанных в начале)

<div class="page-break" style="page-break-before: always;"></div>
