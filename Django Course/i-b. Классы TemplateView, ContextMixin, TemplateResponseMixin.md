TemplateView

Наследование

ContextMixin

TemplateResponseMixin

Краткое summery

### **TemplateView**

**TemplateView** является удобным классом для представлений, которые не нуждаются в сложной бизнес-логике. Его основное преимущество заключается в том, что он позволяет быстро создавать представления, которые отображают HTML-шаблон, без необходимости реализации дополнительного кода в методе `get()`.

Это особенно полезно для таких страниц, как главная, "about", "contact" и другие, где основная задача - просто отобразить статическую информацию, не требующую сложной обработки данных или взаимодействия с моделями. TemplateView упрощает разработку таких простых представлений, позволяя сосредоточиться на шаблонах и контексте, а не на реализации логики в самом представлении.

Чтобы воспользоваться классом **TemplateView** достаточно передать имя шаблона в атрибуте - **`template_name`** и (необязательно) контекст, либо через атрибут - `**extra_context**`, либо переопределив метод `**get_context_data()**`.

Например, можно изменить отображение для страницы с постами по категориям:

```Python
class ShowCatsView(TemplateView):
    template_name = 'basefunc/index.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        category = get_object_or_404(Category, slug=kwargs['cat_slug'])
        filtered_posts = POSTS.filter(cat_id=category.pk)
        context.update({'title': category.title, 'posts': filtered_posts, 'cat_id': category.pk})
        return context
```

```Python
    ...
    path('category/<slug:cat_slug>/', views.ShowCatsView.as_view(), name='category'),
    ...
```

### Наследование

TemplateView - наследуется от `TemplateResponseMixin`, `ContextMixin` и `View`.

```Python
class TemplateView(TemplateResponseMixin, ContextMixin, View):
    """
    Render a template. Pass keyword arguments from the URLconf to the context.
    """

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        return self.render_to_response(context)
```

При наследовании от данного класса и попытке открыть страницу, за которую от отвечает, в первую очередь будет происходить цепочка вызовов методов родительского класса `View`, который мы рассмотрели ранее, в самом конце вызывается метод `get`, который определяет дальнейшую логику работы.

В методе `get` происходят следующие события:

- вызывается метод `get_context_data(**kwargs)` класса `ContextMixin` для формирования контекста шаблона.
- и возвращается результат работы метода `render_to_response(context)` класса `TemplateResponseMixin`, который отвечает за формирование шаблона.

Чтобы лучше понять, как работает этот класс и какие аргументы мы можем использовать, при работе с ним, рассмотрим внутренности классов, от которых он наследуется)

### ContextMixin

Как мы помним, первым из `get` будет вызван метод `get_context_data(**kwargs)`, за логику работы которого отвечает **ContextMixin**.

**ContextMixin** - это миксин, который добавляет функциональность для создания контекста, который будет передан в шаблон.

- Основные атрибуты и методы ContextMixin:
    
    - `extra_context` - словарь, который содержит дополнительные данные, которые должны быть добавлены в контекст.
        
        Помимо определения `extra_context` в классе TemplateView, вы также можете передавать дополнительные данные для контекста через параметр `extra_context` метода `as_view()`. Это может быть полезно, когда вам нужно динамически формировать контекст, основываясь на некоторых внешних факторах, таких как конфигурация, параметры URL или другие переменные окружения. Но при одновременном использовании `extra_context` и в классе и в методе, приоритет будет у того, что был передан через метод as_view().
        
    
    - `get_context_data()` - метод, который возвращает контекст, который будет передан в шаблон. По умолчанию он возвращает словарь, состоящий из значений `extra_context` и параметров, полученных из kwargs (аргументы url-адреса, например, слаг)

```Python
class ContextMixin:
    """
    A default context mixin that passes the keyword arguments received by
    get_context_data() as the template context.
    """

    extra_context = None

    def get_context_data(self, **kwargs):
        kwargs.setdefault("view", self)
        if self.extra_context is not None:
            kwargs.update(self.extra_context)
        return kwargs
```

Исходя из рассмотрения этого класса, мы видим, что мы можем передавать в контекст дополнительные параметры двумя способами, используя атрибут класса `extra_context` или переопределяя логику самого метода `get_context_data` в нашем дочернем классе (на примере выше был использован второй способ). В чём разница? Зачем переопределять метод, если можно передать все необходимые аргументы для контекста, используя `extra_context`, который будет добавлен в основной контекст при вызове метода `get_context_data`?

**Использование** `**extra_context**`**:**

- Простой и удобный способ добавить дополнительные данные в контекст.
- Позволяет добавить **статические данные**, которые не требуют вычислений или сложной логики - заголовок страницы, словарь с пунктами меню, вычисленный заранее список постов.
- Не требует переопределения метода `get_context_data()`.

**Переопределение** `**get_context_data()**`**:**

- Дает больше контроля над формированием контекста.
- Позволяет **динамически вычислять** или получать данные для контекста - параметры, переданные в url-адрес (например, slug) или параметры GET-запроса.
- Может использоваться для сложной логики, требующей доступа к атрибутам представления или другим источникам данных.
- Может комбинироваться с использованием `extra_context`, если есть необходимость как в статических, так и в динамических данных.

**Пример комбинации этих способов:**

```Python
class IndexView(TemplateView):
    template_name = 'basefunc/index.html'
    extra_context = {'title': 'Главная страница', 'posts': POSTS}

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['cat_selected'] = int(self.request.GET.get('cat_id', 0))
        return context
```

Статические параметры (`’title’` и `‘posts’`) были переданы через `extra_context`, значение для динамического параметра `'cat_selected'` из GET-запроса (http://127.0.0.1:8000/category/?**cat_id=2**) получаем через метод `get_context_data`.

Разберём строку `context['cat_selected'] = int(self.request.GET.get('cat_id', 0))` подробнее:

- в `self` хранится объект класса IndexView, созданный во время вызова метода `as_view()`. И у этого объекта есть атрибут **request**, который был присвоен в методе `setup()`.
- У объектf запроса (request) есть атрибут **GET**, в котором хранится QueryDict следующего вида - `QueryDict: {'cat_id': ['2']}` (да, в зайце утка, а в утке яйцо)).
- Далее метод `get()` объекта `QueryDict` возвращает первое значение, связанное с указанным ключом, как строку (или, если аргумент не был передан - 0). И финальным шагом мы приводим строковое значение к числу - `int(...)`.

> [!important]  
> Не забываем вернуть контекст, если переопределяли метод get_context_data)  

### TemplateResponseMixin

С контекстом вроде разобрались, переходим к формированию шаблона)

Напомню, что у нас следующим по списку из метода `get` будет вызван метод - `render_to_response(context)`, за логику которого отвечает класс TemplateResponseMixin.

**TemplateResponseMixin** - это миксин, который добавляет функциональность для создания и возврата TemplateResponse объекта.

- Атрибуты:
    - `template_name` - строка, определяющая путь к шаблону, который будет использован для отображения.
    - `template_engine` - движок шаблона, который будет использоваться для загрузки шаблона. По умолчанию `None`, что говорит Django искать шаблон во всех настроенных движках.
    - `response_class` - класс ответа, который будет возвращен методом `render_to_response`. По умолчанию это `TemplateResponse`.
    - `content_type` - тип содержимого, который будет использоваться для ответа. По умолчанию `None` - означает, что Django использует `'text/html'`.
- Методы:
    - **`get_template_names(self)`****:**
        
        ```Python
            def get_template_names(self):
                """
                Return a list of template names to be used for the request. Must return
                a list. May not be called if render_to_response() is overridden.
                """
                if self.template_name is None:
                    raise ImproperlyConfigured(
                        "TemplateResponseMixin requires either a definition of "
                        "'template_name' or an implementation of 'get_template_names()'"
                    )
                else:
                    return [self.template_name]
        ```
        
        - Этот метод возвращает список имен шаблонов, которые будут использованы для рендеринга ответа.
        - Если атрибут `template_name` класса не определен, метод поднимает исключение `ImproperlyConfigured`, так как для работы `TemplateResponseMixin` необходимо определить либо `template_name`, либо реализовать `get_template_names()`.
        - Если `template_name` определен, метод просто возвращает список, содержащий это значение.
    - **`render_to_response(self, context, **response_kwargs)`****:**
        
        ```Python
            def render_to_response(self, context, **response_kwargs):
                """
                Return a response, using the `response_class` for this view, with a
                template rendered with the given context.
        
                Pass response_kwargs to the constructor of the response class.
                """
                response_kwargs.setdefault("content_type", self.content_type)
                return self.response_class(
                    request=self.request,
                    template=self.get_template_names(),
                    context=context,
                    using=self.template_engine,
                    **response_kwargs,
                )
        ```
        
        - Этот метод отвечает за создание и возвращение ответа HTTP, используя указанный контекст и шаблон.
        - Он использует атрибут `response_class` для создания объекта ответа.
        - Метод устанавливает значение `content_type` для ответа, используя атрибут `content_type` класса, если он не был уже установлен в `response_kwargs`.
        - Затем он создает и возвращает объект ответа, используя следующие аргументы:
            - `request`: текущий объект `request`.
            - `template`: список имен шаблонов, возвращаемых методом `get_template_names()`.
            - `context`: контекст, переданный в `render_to_response()`.
            - `using`: значение `template_engine` класса, которое указывает, какой шаблонизатор должен быть использован.
            - любые дополнительные аргументы, переданные в `response_kwargs`.
        
        То есть по сути на этом шаге (если ничего не переопределять и передать только `template_name`) происходит создание и возврат объекта класса `TemplateResponse` (внука класса `HttpResponse`)) с переданными атрибутами - request, шаблон, контекст и т.д.
        
        Хотя TemplateView по умолчанию используется для рендеринга HTML-шаблонов, его можно применять и для других типов ответов, таких как JSON. Это может быть полезно, если вам нужно создать API-представление, которое возвращает данные в формате JSON, но при этом использует шаблонизацию для формирования ответа.
        
        Для этого можно переопределить атрибут `response_class` класса TemplateView, указав вместо `TemplateResponse` другой класс ответа, например, `JsonResponse`. Таким образом, TemplateView будет использовать шаблонизацию для формирования JSON-ответа, а не HTML-страницы.
        

### Краткое summery

1. `template_name` - строка, указывающая путь к шаблону, который будет использоваться для отображения. Этот атрибут является обязательным, если не переопределен метод `get_template_names()`. Если `template_name` не указан, Django выбросит исключение `ImproperlyConfigured`.
2. `extra_context` - словарь, содержащий дополнительные данные, которые должны быть добавлены в контекст шаблона. Эти данные будут доступны в шаблоне наряду с другими переменными контекста. Удобно использовать для передачи статических данных, не требующих сложной логики.
3. `template_engine` - строка, указывающая на движок шаблонов, который будет использоваться для рендеринга шаблона. По умолчанию `None`, что означает использование движка шаблонов по умолчанию, настроенного в Django. Можно указать конкретный движок, если в проекте используются несколько.
4. `response_class` - класс, который будет использоваться для создания HTTP-ответа. По умолчанию это `TemplateResponse`, но можно переопределить, чтобы использовать другой класс ответа, например, `JsonResponse`, если нужно вернуть JSON-данные вместо HTML.
5. `content_type` - строка, указывающая тип содержимого (MIME-тип) ответа. По умолчанию `None`, что приводит к использованию значения `'text/html'`. Можно переопределить, если нужно указать другой тип содержимого, например, `'application/json'` для JSON-ответа.

Эти атрибуты предоставляют гибкость в настройке и расширении функциональности класса TemplateView. Они позволяют указать шаблон для рендеринга, передать дополнительные данные в контекст, выбрать движок шаблонов, изменить класс ответа и указать тип содержимого.

**Переопределение методов в подклассах TemplateView дает еще больше возможностей:**

- `get_context_data(**kwargs)`: переопределение этого метода позволяет динамически формировать контекст шаблона, используя любую необходимую логику, например, получение данных из базы данных, обработку параметров запроса и т.д.
- `get_template_names()`: переопределение этого метода позволяет динамически определять список имен шаблонов в зависимости от определенных условий, например, на основе параметров запроса или свойств пользователя.
- `render_to_response(context, **response_kwargs)`: переопределение этого метода позволяет настроить процесс создания HTTP-ответа, например, добавить заголовки, изменить статус код или сериализовать данные в нужный формат.

<div class="page-break" style="page-break-before: always;"></div>
