Параметр next

Декоратор login_required()

Класс LoginRequiredMixin

### Параметр `next`

Параметр `next` - это **query parameter**, который используется для указания URL-адреса, на который следует перенаправить пользователя после успешной аутентификации.

![[Untitled 12.png|Untitled 12.png]]

Имя `‘next’` используется в Django по умолчанию и определенно в константе `REDIRECT_FIELD_NAME = "next”`. Мы можем определить своё имя параметра для классов, которые наследуются от миксина - **RedirectURLMixin** (например, LoginView и LogoutView), используя атрибут - `redirect_field_name`.

1. **Автоматическая обработка Django:**
    
    При использовании встроенных инструментов Django, таких как декоратор `login_required` или класс `LoginRequiredMixin`, Django автоматически обрабатывает создание, передачу и использование параметра `next`.
    
    - Когда неаутентифицированный пользователь пытается получить доступ к защищенной странице, Django автоматически перенаправляет его на страницу входа. В этот момент URL-адрес защищенной страницы сохраняется в параметре `next`.
    - Значение параметра `next` добавляется к URL-адресу страницы входа. Например, если пользователь пытается получить доступ к `/protected-page/`, а страница входа находится по адресу `/login/`, то полный URL-адрес перенаправления будет выглядеть так: `/login/?next=/protected-page/`.
    - После успешной аутентификации пользователя Django проверяет наличие параметра `next` в URL-адресе. Если параметр присутствует и его значение является допустимым внутренним URL-адресом приложения, Django перенаправляет пользователя на указанный URL-адрес.
    - Если параметр `next` отсутствует или его значение не является допустимым URL-адресом, Django перенаправляет пользователя на URL-адрес, указанный в настройке `settings.LOGIN_REDIRECT_URL` (по умолчанию это `/accounts/profile/`).
2. **Ручная обработка:**
    
    Если вы реализуете собственную логику аутентификации и перенаправления или хотите настроить поведение перенаправления, вы можете в ручную передать параметр `next` в функции представлении:
    
    ```Python
    from django.urls import reverse
    from django.shortcuts import render, redirect
    
    def about_view(request):
        if not request.user.is_authenticated:
            login_url = reverse('users:login')
            return redirect(f"{login_url}?next={request.path}")
    
        return render(request, 'basefunc/about.html', {'title': 'О сайте'})
    ```
    
3. **Возврат на страницу после регистрации:**
    
    В случае, когда страница не требует авторизации, но пользователь решает войти в систему, можно реализовать перенаправление пользователя обратно на страницу, с которой он пришел, следующим образом:
    
    1. На каждой странице, где отображается ссылка на страницу входа (например, в шаблоне базовой страницы), добавьте параметр `next` в URL ссылки на страницу входа, указывая текущий URL.  
        Здесь  
        `request.path` представляет текущий URL-путь страницы.
        
        ```HTML
        <a href="{% url 'login' %}?next={{ request.path }}">Войти</a>
        ```
        
    2. В класс представление автоматически будет передан атрибут `next` со значением пути до страницы, с которой вы перешли на страницу авторизации. Здесь важно учесть тот момент, что если пользователь, находясь на странице авторизации ещё раз перейдёт на страницу авторизации, то после авторизации он будет перенаправлен на страницу авторизации))
        
        Поэтому дополнительно желательно переопределить метод `get_redirect_url`:
        
        ```Python
        class LoginUser(LoginView):
            authentication_form = LoginUserForm
            template_name = 'users/login.html'
            extra_context = {'title': 'Авторизация'}
            next_page = reverse_lazy('home')
        
            def get_redirect_url(self):
                redirect_to = self.request.POST.get(
                    self.redirect_field_name, self.request.GET.get(self.redirect_field_name)
                )
                if redirect_to == reverse('users:login'):
                    redirect_to = self.next_page
        
                url_is_safe = url_has_allowed_host_and_scheme(
                    url=redirect_to,
                    allowed_hosts=self.get_success_url_allowed_hosts(),
                    require_https=self.request.is_secure(),
                )
                return redirect_to if url_is_safe else ""
        ```
        

В большинстве случаев **нет необходимости** явно прописывать в шаблоне скрытое поле `<input type="hidden" name="next" value="{{ next }}">`, если вы используете встроенные инструменты Django, такие как декоратор `login_required` или класс `LoginRequiredMixin`.

Однако, есть несколько ситуаций, когда вы можете захотеть явно указать скрытое поле `next` в шаблоне:

1. **Кастомная форма входа:** Если вы создаете свою собственную форму входа вместо использования встроенной формы `AuthenticationForm`, вам может потребоваться явно добавить скрытое поле `next` в шаблон формы. Это гарантирует, что значение `next` будет передано при отправке формы.
2. **Несколько страниц входа:** Если в вашем приложении есть несколько страниц входа (например, отдельные страницы для обычного входа и входа через социальные сети), и вы хотите перенаправлять пользователя на определенную страницу после успешной аутентификации, вы можете явно указать скрытое поле `next` в каждом шаблоне страницы входа.
3. **Сложная логика перенаправления:** Если у вас есть специфическая логика перенаправления, которая не может быть легко реализована с помощью встроенных механизмов Django, вы можете передавать значение `next` через скрытое поле в шаблоне и обрабатывать его вручную в представлении.

Тем не менее, в большинстве случаев, когда вы используете встроенные инструменты Django и следуете стандартным соглашениям, нет необходимости явно указывать скрытое поле `next` в шаблоне. Django автоматически обрабатывает передачу и использование параметра `next` без дополнительных настроек в шаблоне.

> [!important]  
> При ручной обработке параметра next важно проверять и подтверждать значение next, чтобы предотвратить потенциальные уязвимости безопасности, такие как "Open Redirect". Django предоставляет функцию django.utils.http.is_safe_url(), которая помогает проверить, является ли URL безопасным для перенаправления.  

### Декоратор login_required()

Декоратор `login_required()` является удобным инструментом в Django, который позволяет ограничить доступ к определенным функциям представлениям (views) только для аутентифицированных пользователей. Если пользователь не авторизован и пытается получить доступ к представлению, защищенному этим декоратором, он будет перенаправлен на страницу входа.

```Python
@login_required
def add_page(request):
	...
```

**Принцип работы:**

Реализация декоратора `login_required()` в коде использует другой декоратор `user_passes_test()`. Он проверяет, является ли пользователь аутентифицированным с помощью лямбда-функции `lambda u: u.is_authenticated`.

Если пользователь не авторизован, то декоратор перенаправляет его на страницу входа, указанную в `settings.LOGIN_URL`. При этом текущий абсолютный путь передается в строке запроса в параметре `next`. Например: `/accounts/login/?next=/polls/3/`.

Если пользователь авторизован, то представление выполняется как обычно.

**Опциональные аргументы декоратора:**

```Python
def login_required(
    function=None, redirect_field_name=REDIRECT_FIELD_NAME, login_url=None
)
```

- `function`: принимает функцию представление.
- `redirect_field_name`:
    - Позволяет указать пользовательское имя параметра строки запроса для сохранения пути перенаправления.
    - По умолчанию используется `"next"`.
- `login_url`:
    - Позволяет указать пользовательский URL для страницы входа.
    - Если не указан, необходимо убедиться, что `settings.LOGIN_URL` и представление для входа правильно связаны.

> [!important]  
> Декоратор login_required НЕ проверяет флаг is_active у пользователя, но AUTHENTICATION_BACKENDS по умолчанию отклоняет неактивных пользователей.  
  
> [!important]  
> Если вы пишете пользовательские представления для админки Django (или вам нужна та же проверка авторизации, которую используют встроенные представления), то декоратор django.contrib.admin.views.decorators.staff_member_required() может показаться вам полезной альтернативой login_required(). Если пользователь вошел в систему, является сотрудником (User.is_staff=True) и активен (User.is_active=True), выполняет представление.  

### Класс LoginRequiredMixin

Класс `LoginRequiredMixin` является миксином в Django, который обеспечивает функциональность, аналогичную декоратору `login_required()`, для классов-представлений (class-based views).

Он позволяет ограничить доступ к определенным представлениям только для аутентифицированных пользователей. Если пользователь не авторизован и пытается получить доступ к представлению, использующему этот миксин, он будет перенаправлен на страницу входа или получит ошибку HTTP 403 Forbidden, в зависимости от значения параметра `raise_exception`.

```Python
class MyView(LoginRequiredMixin, View):
    login_url = "/login/"
    redirect_field_name = "redirect_to"
```

**Наследование:**

`LoginRequiredMixin` должен быть расположен в самом левом положении в списке наследования класса представления. Сам он наследуется от класса `AccessMixin`, который предоставляет настраиваемую функциональность для миксинов доступа.

**Принцип работы:**

Реализация класса `LoginRequiredMixin` переопределяет метод `dispatch()`, который является точкой входа для обработки запросов в класс-представлениях. Метод `dispatch()` проверяет, авторизован ли текущий пользователь, используя свойство `request.user.is_authenticated`.

Если пользователь не авторизован, вызывается метод `handle_no_permission()`, унаследованный от `AccessMixin`. Этот метод либо возбуждает исключение `PermissionDenied`, либо перенаправляет пользователя на страницу входа, указанную в `login_url`, передавая текущий абсолютный путь в параметре строки запроса, указанном в `redirect_field_name`.

Если пользователь авторизован, метод `dispatch()` вызывает метод `dispatch()` родительского класса (`super().dispatch()`), который продолжает обработку запроса.

**Настраиваемые параметры:**

Класс `LoginRequiredMixin` наследует параметры от `AccessMixin`, которые можно настроить для изменения поведения при обработке неавторизованных пользователей:

- `login_url`: URL страницы входа. По умолчанию `None`.
- `permission_denied_message`: Сообщение, отображаемое при возбуждении исключения `PermissionDenied`. По умолчанию пустая строка.
- `raise_exception`: Флаг, указывающий, следует ли возбуждать исключение `PermissionDenied` вместо перенаправления на страницу входа. По умолчанию `False`.
- `redirect_field_name`: Имя параметра строки запроса, используемого для сохранения пути перенаправления. По умолчанию ссылается на константу `REDIRECT_FIELD_NAME`.

> [!important]  
> Как и декоратор login_required, LoginRequiredMixin НЕ проверяет флаг is_active у пользователя, но AUTHENTICATION_BACKENDS по умолчанию отклоняет неактивных пользователей.

<div class="page-break" style="page-break-before: always;"></div>
