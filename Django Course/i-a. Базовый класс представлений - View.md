Function-based Views vs Class-based Views

as_view()

View класс

Краткое summery

### **Function-based Views vs Class-based Views**

**Функции-представления** являются наиболее простым и базовым способом определения логики обработки запросов в Django. Они представляют собой обычные Python-функции, которые принимают запрос в качестве первого аргумента и возвращают HTTP-ответ. Этот подход хорошо подходит для простых сценариев, где требуется минимальная логика обработки запросов. Функции-представления просты в написании и понимании, что делает их привлекательным вариантом, особенно для начинающих разработчиков.

С другой стороны, **классы-представления** предоставляют более структурированный и расширяемый подход. Они основаны на ООП-принципах и наследуют функциональность от базовых классов, таких как `View` или его производные. Это позволяет легко повторно использовать код, переопределять и расширять поведение представлений. Классы-представления также предоставляют специальные методы, такие как `get()`, `post()`, `put()` и т.д., которые делают код более читаемым и понятным. Этот подход особенно полезен для более сложных приложений, где требуется гибкость и возможность расширения.

Выбор между функциями-представлениями и классами-представлениями зависит от конкретных требований вашего проекта. Для простых сценариев функции-представления могут быть более подходящими, поскольку они проще в реализации. Однако для более сложных приложений, где важны повторное использование кода, расширяемость и структурированность, классы-представления, как правило, являются предпочтительным выбором. Многие опытные разработчики Django предпочитают использовать классы-представления, поскольку они предоставляют более масштабируемый и поддерживаемый подход.

> [!important]  
> Все представления наследуются от класса View, который управляет связыванием представления с URL, диспетчеризацией HTTP-методов и другими общими функциями. RedirectView обеспечивает HTTP-переадресацию, а TemplateView расширяет базовый класс, чтобы он также мог отрисовывать шаблон.  

### as_view()

Метод `as_view()` является крайне важным при использовании классов-представлений в Django. Использование данного метода позволяет Django правильно обрабатывать классы-представления, как если бы они были обычными view-функциями. Это делает использование классов-представлений более интуитивным и соответствующим общему подходу к определению маршрутов в Django.

Предположим, у нас есть класс-представление `MyView`, который наследуется от базового класса `View`:

```Python
from django.views import View
from django.http import HttpResponse

class MyView(View):
    def get(self, request):
        return HttpResponse("Hello, world!")
```

Теперь, чтобы использовать этот класс-представление в нашем URLconf, мы можем написать следующее:

```Python
from django.urls import path
from .views import MyView

urlpatterns = [
    path('my-view/', MyView.as_view(), name='my-view'),
]
```

Обратите внимание на вызов `MyView.as_view()`. Что происходит за кулисами?

1. `as_view()` является методом класса, определенным в базовом `View` классе. Когда мы вызываем этот метод, он создает и возвращает функцию view, которая может быть использована в маршруте.
2. Внутри `as_view()` метода происходит следующее:
    - Создается экземпляр класса `MyView`.
    - Метод `dispatch()` определяется на этом экземпляре. Он отвечает за перенаправление запроса на соответствующий метод обработки (в данном случае, `get()`).
    - Возвращается функция view, которая инкапсулирует всю эту логику.
3. Когда Django получает HTTP-запрос, соответствующий этому маршруту, он вызывает возвращенную функцию view. Эта функция, в свою очередь, создает экземпляр `MyView`, вызывает `dispatch()` метод, который определяет, что нужно вызвать `get()` метод, и, в конечном итоге, возвращает `HttpResponse("Hello, world!")`.

Без метода `as_view()` использование классов-представлений было бы гораздо более сложным, так как разработчику пришлось бы самостоятельно создавать экземпляры классов и вызывать нужные методы обработки запросов. Метод `as_view()` скрывает эту сложность и предоставляет простой и удобный способ интеграции классов-представлений в маршруты приложения.

Также метод `as_view()` позволяет передавать аргументы, которые будут использоваться при создании экземпляра класса-представления. Это дает больше гибкости при определении маршрутов.

### View класс

Базовый класс `View` является основой для создания классов-представлений в Django. Он определяет основные методы и атрибуты, необходимые для обработки HTTP-запросов.

Чтобы лучше понять этот класс разберём его жизненный цикл на следующем примере. В начале занятий, у нас была определена функция представление для главной страницы:

```Python
from django.shortcuts import render


POSTS = Post.published.all()

def index(request):
    data = {
        'title': 'Главная страница',
        'posts': POSTS,
    }

    return render(request, 'basefunc/index.html', data)
```

Используя наследование от базового класса View, мы можем переписать её следующим образом:

```Python
from django.shortcuts import render
from django.views import View

POSTS = Post.published.all()

class IndexView(View):
    def get(self, request):
        data = {
            'title': 'Главная страница',
            'posts': POSTS,
        }
        return render(request, 'basefunc/index.html', data)
```

И не забыть изменить в urls.py функцию представление на класс:

```Python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.IndexView.as_view(), name='home'),
```

**Что будет происходить внутри Django при GET-запросе к нашей главной странице?**

1. Когда пользователь переходит по URL-адресу главной страницы, Django получает этот HTTP-запрос и вызывает метод `as_view()` класса IndexView, зарегистрированного для этого URL-маршрута. Так как в метод можно передавать именованные аргументы, то в первую очередь будет запущена пара проверок для этих аргументов:
    
    ```Python
        def as_view(cls, **initkwargs):
            """Main entry point for a request-response process."""
            for key in initkwargs:
                if key in cls.http_method_names:
                    raise TypeError(
                        "The method name %s is not accepted as a keyword argument "
                        "to %s()." % (key, cls.__name__)
                    )
                if not hasattr(cls, key):
                    raise TypeError(
                        "%s() received an invalid keyword %r. as_view "
                        "only accepts arguments that are already "
                        "attributes of the class." % (cls.__name__, key)
                    )
    	        ...
    ```
    
    - **TypeError с сообщением "The method name %s is not accepted as a keyword argument to %s()":**
        - Это исключение возникает, если в `initkwargs` передается ключ, который совпадает с именем одного из HTTP-методов, поддерживаемых классом `View`.
        - Например, если вы попытаетесь вызвать `MyView.as_view(get=my_custom_get_method)`, это вызовет данное исключение, потому что "get" является именем одного из HTTP-методов, определенных в `View`. Полный список методов рассмотрим далее.
        - Причина вызова этого исключения заключается в том, что `as_view()` не должен принимать HTTP-методы в качестве именованных аргументов. Вместо этого, эти методы должны быть определены как атрибуты класса.
    - **TypeError с сообщением "%s() received an invalid keyword %r. as_view only accepts arguments that are already attributes of the class.":**
        - Это исключение возникает, если в `initkwargs` передается ключ, который не является существующим атрибутом класса.
        - Например, если вы попытаетесь вызвать `MyView.as_view(some_custom_arg=123)`, и `MyView` не имеет атрибута `some_custom_arg`, будет вызвано это исключение.
        - Причина вызова этого исключения заключается в том, что `as_view()` должен принимать только аргументы, которые уже определены как атрибуты класса. Это гарантирует, что все необходимые атрибуты будут установлены корректно при создании экземпляра класса-представления.
2. Если исключений не возникло, то метод `as_view()` создает и возвращает callable-объект (по сути замену для стандартной функции представления), который скрывает в себе всю внутреннюю реализацию класса представления, такую как создание экземпляра класса, инициализацию, делегирование на правильный обработчик и возврат ответа. Этот callable-объект ведет себя как функция, которую можно вызывать, передавая ей запрос в качестве аргумента.
    
    За создание callable-объекта отвечает данная часть метода as_view():
    
    ```Python
    view.view_class = cls
    view.view_initkwargs = initkwargs
    
    # __name__ and __qualname__ are intentionally left unchanged as
    # view_class should be used to robustly determine the name of the view
    # instead.
    view.__doc__ = cls.__doc__
    view.__module__ = cls.__module__
    view.__annotations__ = cls.dispatch.__annotations__
    # Copy possible attributes set by decorators, e.g. @csrf_exempt, from
    # the dispatch method.
    view.__dict__.update(cls.dispatch.__dict__)
    
    # Mark the callback if the view class is async.
    if cls.view_is_async:
        markcoroutinefunction(view)
    
    return view
    ```
    
    - **Установка атрибутов callable-объекта**:
        - `view.view_class = cls`: Устанавливается атрибут `view_class` на созданный callable-объект, указывающий на исходный класс-представление.
        - `view.view_initkwargs = initkwargs`: Устанавливается атрибут `view_initkwargs` на callable-объект, содержащий аргументы, с которыми был вызван `as_view()`.
    - **Копирование метаданных**:
        - Копируются различные метаданные (документация, модуль, аннотации, словарь атрибутов) с исходного класса-представления на callable-объект. Это позволяет сохранять информацию о классе-представлении.
    - **Маркировка асинхронных представлений**:
        - Если класс-представление является асинхронным (определен с помощью `async def`), callable-объект помечается как корутина с помощью `markcoroutinefunction()`.
3. После чего происходит вызов этого объекта, который содержит в себе следующий код:
    
    ```Python
    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, "request"):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
        return self.dispatch(request, *args, **kwargs)
    ```
    
    - **Создание экземпляра класса**:
        
        - **`self = cls(**initkwargs)`**: Здесь создается экземпляр класса-представления (`cls`) с использованием аргументов, переданных в `initkwargs`. Это позволяет передавать дополнительные параметры при вызове `as_view()`. В `__init__` ничего интересного не происходит, просто присваиваются атрибуты, если они были переданы.
        
        ```Python
            def __init__(self, **kwargs):
                """
                Constructor. Called in the URLconf; can contain helpful extra
                keyword arguments, and other things.
                """
                # Go through keyword arguments, and either save their values to our
                # instance, or raise an error.
                for key, value in kwargs.items():
                    setattr(self, key, value)
        ```
        
    - **Инициализация представления**:
        - **`self.setup(request, *args, **kwargs)`**: Вызывается метод `setup()` на созданном экземпляре. Этот метод отвечает за инициализацию представления и установку необходимых атрибутов, таких как `request`, `args` и `kwargs`.
            
            ```Python
                def setup(self, request, *args, **kwargs):
                    """Initialize attributes shared by all view methods."""
                    if hasattr(self, "get") and not hasattr(self, "head"):
                        self.head = self.get
                    self.request = request
                    self.args = args
                    self.kwargs = kwargs
            ```
            
            **На этом шаге происходит:**
            
            1. Проверка наличия метода `get()`:
                - `if hasattr(self, "get") and not hasattr(self, "head"):`: Выполняется проверка, определен ли в классе-представлении метод `get()`. Если он есть, но при этом нет метода `head()`, то это значит, что разработчик не реализовал обработку HEAD-запросов.
            2. Установка метода `head()`:
                - `self.head = self.get`: Если метод `head()` не определен, но есть метод `get()`, то метод `head()` устанавливается как ссылка на метод `get()`. Это позволяет обрабатывать HEAD-запросы так же, как GET-запросы.
            3. Установка атрибутов `request`, `args` и `kwargs`:
                - `self.request = request`: Атрибут `request` устанавливается как переданный в метод `setup()` объект `HttpRequest`.
                - `self.args = args`: Атрибут `args` устанавливается как кортеж неименованных аргументов, переданных в URL-шаблон.
                - `self.kwargs = kwargs`: Атрибут `kwargs` устанавливается как словарь именованных аргументов, переданных в URL-шаблон.
            
            **Зачем происходит присвоение этих атрибутов объекту класса?**
            
            1. Доступ к данным запроса:
                - Устанавливая `request`, `args` и `kwargs` как атрибуты объекта, методы класса-представления (например, `get()`, `post()`) получают к ним доступ. Это позволяет использовать эти данные при обработке запроса.
            2. Соответствие поведению функций-представлений:
                - Класс-представление должен вести себя так же, как и функция-представление. В функциях-представлениях данные запроса (request, args, kwargs) передаются в качестве аргументов. Установка этих данных как атрибутов обеспечивает аналогичное поведение. Например, если у вас определен маршрут с параметром `<slug:post_slug>`, то этот параметр будет доступен через `self.kwargs['post_slug']` внутри вашего класса-представления `ShowPostView`.
    - **Проверка наличия атрибута** `**request**`:
        - **`if not hasattr(self, "request"): raise AttributeError(...)`**: Проверяется, что у экземпляра класса-представления есть атрибут `request`. Это необходимо, потому что `setup()` **должен** устанавливать этот атрибут. Если он не установлен, возникает ошибка с соответствующим сообщением.
            
            **Почему проверка происходит после вызова setup()?**
            
            1. `setup()` метод отвечает за инициализацию атрибутов класса-представления, в том числе и `self.request`.
            2. Однако, если разработчик переопределит метод `setup()` и забудет вызвать `super().setup()`, то атрибут `self.request` может не быть установлен.
            3. Поэтому, чтобы гарантировать, что `self.request` доступен, Django проверяет его наличие после вызова `setup()`.
            
            Если `self.request` не будет установлен, Django выбросит `AttributeError` с понятным сообщением об ошибке, чтобы помочь разработчику понять, что он забыл вызвать `super().setup()` в переопределенном методе.
            
            Таким образом, эта проверка является защитным механизмом, который помогает обнаружить ошибки, связанные с неправильным переопределением метода `setup()`. Она выполняется не после установки `self.request`, а после вызова `setup()`, чтобы гарантировать, что атрибут был установлен корректно.
            
    - **Вызов** `**dispatch()**`:
        
        - **`return self.dispatch(request, *args, **kwargs)`**: После инициализации, вызывается метод `dispatch()` на созданном экземпляре. Этот метод отвечает за определение HTTP-метода запроса и перенаправление его на соответствующий обработчик (например, `get()`, `post()`).
        
        ```Python
            def dispatch(self, request, *args, **kwargs):
                # Try to dispatch to the right method; if a method doesn't exist,
                # defer to the error handler. Also defer to the error handler if the
                # request method isn't on the approved list.
                if request.method.lower() in self.http_method_names:
                    handler = getattr(
                        self, request.method.lower(), self.http_method_not_allowed
                    )
                else:
                    handler = self.http_method_not_allowed
                return handler(request, *args, **kwargs)
        ```
        
        - Сначала метод проверяет, что HTTP-метод запроса (`request.method.lower()`) содержится в списке разрешенных методов (`self.http_method_names`):
        
        `http_method_names = [ "get", "post", "put", "patch", "delete", "head", "options", "trace",]`
        
        - Если метод разрешен, то он получает соответствующий обработчик (`handler = getattr(self, request.method.lower(), self.http_method_not_allowed)`).
        - Если метод не разрешен, то используется обработчик `http_method_not_allowed()`.
        - В конце метод вызывает выбранный обработчик, передавая ему `request`, `args` и `kwargs`.
        
        **Итого**: если мы реализовали внутри нашего класса представления метод - **get** и получили **GET-запрос**, то после всей этой вереницы запросов будет вызван метод `get`, логику которого мы прописали и сформирует HTTP-ответ🥳
        
        ```Python
        class IndexView(View):
            def get(self, request):
                data = {
                    'title': 'Главная страница',
                    'posts': POSTS,
                }
                return render(request, 'basefunc/index.html', data)
        ```
        
        Если же мы получили какой-то не корректный метод, который не прописан в списке разрешённых методов, то будет вызван `http_method_not_allowed`
        
        ```Python
            def http_method_not_allowed(self, request, *args, **kwargs):
                logger.warning(
                    "Method Not Allowed (%s): %s",
                    request.method,
                    request.path,
                    extra={"status_code": 405, "request": request},
                )
                response = HttpResponseNotAllowed(self._allowed_methods())
        
                if self.view_is_async:
        
                    async def func():
                        return response
        
                    return func()
                else:
                    return response
        ```
        
        - Он логирует предупреждение, содержащее информацию о запрошенном методе и пути.
        - Затем он создает и возвращает объект `HttpResponseNotAllowed` с заголовком `Allow`, который содержит список разрешенных HTTP-методов.
        - Если представление является асинхронным (`self.view_is_async`), то ответ оборачивается в корутину.
        
        Если же на основную страницу придёт запрос, отличный от GET (например, POST, PUT, DELETE и т.д.), а в нашем классе представления определён только метод `get()`, то будет сгенерировано исключение `AttributeError`. Это произойдёт потому, что Django ожидает, что класс представления будет определять методы для обработки всех типов HTTP запросов, которые могут быть получены.
        
        Чтобы избежать этой ошибки, можно использовать декораторы, такие как `require_http_methods` или `require_GET`, чтобы явно указать, какие типы запросов разрешены для представления.
        
        **Последние методы, которые мы не разобрали для класс View:**
        
        1. `**options(self, request, *args, **kwargs)**`:
            - Этот метод обрабатывает HTTP-метод `OPTIONS`, который используется для получения информации о доступных методах для данного ресурса.
            - Он создает объект `HttpResponse` и устанавливает в нем заголовок `Allow` с перечислением разрешенных HTTP-методов.
            - Также устанавливается заголовок `Content-Length` со значением 0, так как тело ответа для `OPTIONS` обычно пустое.
            - Если представление является асинхронным (`self.view_is_async`), то ответ оборачивается в корутину.
        2. `**_allowed_methods(self)**`:
            - Этот вспомогательный метод возвращает список разрешенных HTTP-методов для данного класса-представления.
            - Он проверяет, какие методы класса соответствуют именам HTTP-методов в `self.http_method_names`, и возвращает их в верхнем регистре.

> [!important]  
> Использование View класса в качестве базового позволяет создавать более структурированные, расширяемые и повторно используемые классы-представления. Разработчики могут легко переопределять и дополнять методы View класса, чтобы реализовать необходимую логику обработки запросов. Это делает классы-представления более гибкими и масштабируемыми по сравнению с традиционными функциями-представлениями.  

### Краткое summery

1. `http_method_names` - список HTTP-методов, которые может обрабатывать класс-представление. По умолчанию включает методы 'get', 'post', 'put', 'patch', 'delete', 'head', 'options' и 'trace'. Этот атрибут можно переопределить в подклассах, чтобы ограничить доступные методы.
2. `request` - объект `HttpRequest`, представляющий текущий запрос. Он устанавливается в методе `setup()` перед вызовом метода-обработчика.
3. `args` - кортеж позиционных аргументов, извлеченных из URL-шаблона. Также устанавливается в методе `setup()`.
4. `kwargs` - словарь именованных аргументов, извлеченных из URL-шаблона. Устанавливается в методе `setup()`.
5. `http_method_not_allowed` - метод, который вызывается, если запрошенный HTTP-метод не разрешен для данного класса-представления (не включен в `http_method_names`). По умолчанию возвращает ответ с кодом 405 (Method Not Allowed).
6. `view_is_async` - атрибут, указывающий, является ли класс-представление асинхронным (определен с помощью `async def`). Устанавливается в методе `as_view()`.

Эти атрибуты играют важную роль в функционировании класса `View` и его подклассов. Они позволяют контролировать доступные HTTP-методы, получать доступ к данным запроса и аргументам URL, а также обрабатывать случаи, когда запрошенный метод не разрешен.

<div class="page-break" style="page-break-before: always;"></div>
