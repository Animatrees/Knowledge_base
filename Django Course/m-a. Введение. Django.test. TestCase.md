Совсем кратко о тестировании

Тестирование в Django - ключевые поинты

Описание процедуры тестирования

django.test

TestCase

### Совсем кратко о тестировании

Тестирование веб-приложений включает проверку функциональности, производительности, безопасности, и удобства использования веб-сайта или веб-приложения, чтобы убедиться, что оно работает корректно и удовлетворяет требованиям пользователей.

**Преимущества для разработчика:**

- Тесты помогают убедиться, что новый код работает так, как ожидалось, и соответствуют требованиям.
- При изменении или улучшении старого кода тесты гарантируют, что изменения не привели к неожиданным проблемам в приложении.
- Автоматические тесты упрощают интеграцию новых функций и модулей, обеспечивая совместимость всех компонентов системы.
- Тесты позволяют быстро выявлять и локализовать ошибки, что значительно ускоряет процесс их исправления.
- Регулярное тестирование способствует написанию более чистого и поддерживаемого кода, так как разработчики уделяют больше внимания деталям и структуре программ.
- Тесты служат дополнительной документацией, показывающей, как должно вести себя приложение в различных сценариях.

### Тестирование в Django - ключевые поинты

Тестирование в Django построено на базе встроенной библиотеки `unittest` из стандартной библиотеки Python.

- **Структура тестов:**
    - Тесты создаются в файлах с именем `tests.py` внутри каждого приложения или в отдельной папке `tests` с подмодулями для организации большого количества тестов.
    - Тесты обычно организуются в классы, наследуемые от `django.test.TestCase`, которые предоставляют множество полезных методов и интеграцию с Django ORM.
- **Создание тестовой базы данных:**
    - Django автоматически создает отдельную тестовую базу данных для выполнения тестов, что позволяет изолировать тесты от основной базы данных и обеспечивает чистоту данных для каждого теста.
    - После завершения тестов база данных удаляется.
- **Использование фикстур:**
    - Фикстуры позволяют загрузить предварительно подготовленные данные в базу данных перед выполнением тестов.
    - Фикстуры могут быть в формате JSON, XML, или YAML.
- **Запуск тестов:**
    
    - Все тесты: `python manage.py test`
    - Тесты конкретного приложения: `python manage.py test <app_name>`
    - Тесты конкретного класса: `python manage.py test <app_name>.tests.<ClassName>`
    - Тест конкретного метода: `python manage.py test <app_name>.tests.<ClassName>.<method_name>`
    - Тесты в указанной директории: `python manage.py test <directory_path>`
    - Тесты с определенным паттерном имени файла: `python manage.py test --pattern="<pattern>"`
    - Прерывание тестов с выводом результатов текущего теста: `Ctrl-C`
    - Немедленное прерывание тестов: `Ctrl-C` (два раза)
    
    > [!important]  
    > Неплохо бы запускать тесты с включенными предупреждениями Python: python -Wa manage.py test. Флаг -Wa указывает Python на отображение предупреждений об устаревании. Django, как и многие другие библиотеки Python, использует эти предупреждения, чтобы отметить, когда функции исчезают. Также он может отметить места в вашем коде, которые не являются строго неправильными, но могут выиграть от лучшей реализации.  
    

### Описание процедуры тестирования

Когда вы запускаете команду `./manage.py test` в Django, происходит следующий процесс:

1. **Предварительная настройка:**  
    Django выполняет глобальную настройку для подготовки к тестам, настраивая необходимые параметры.  
    
2. **Поиск тестов:**  
    Django обходит все файлы в текущем каталоге и ниже, ищет те, что начинаются с  
    `test` и заканчиваются на `.py`, чтобы найти тесты.
3. **Создание тестовых баз данных:**  
    Для обеспечения изоляции и чистоты данных, Django создает отдельные базы данных специально для тестов.  
    
4. **Применение миграций:**  
    Django выполняет миграции на этих тестовых базах данных, чтобы установить все модели и начальные данные, необходимые для корректного выполнения тестов.  
    
5. **Системные проверки:**  
    Django проводит ряд проверок, чтобы убедиться, что конфигурация и код не содержат очевидных ошибок.  
    
6. **Запуск тестов:**  
    Django запускает все найденные тесты, выполняя их один за другим и собирая результаты.  
    
7. **Удаление тестовых баз данных:**  
    После завершения всех тестов, Django удаляет тестовые базы данных, освобождая ресурсы.  
    
8. **Заключительная очистка:**  
    Django выполняет любые необходимые действия по очистке, восстанавливая исходные параметры.  
    

### django.test

Модуль `django.test` предоставляет инструменты и классы для написания и выполнения тестов в Django.

**Основные компоненты и возможности этого модуля:**

1. **TestCase:**
    - Наследуется от `TransactionTestCase`.
    - Включает методы для работы с базой данных, такие как `setUp()` и `tearDown()`, которые выполняются перед и после каждого теста соответственно.
    - Автоматически использует отдельную тестовую базу данных для каждого теста.
2. **TransactionTestCase:**
    - Наследуется от `SimpleTestCase`.
    - Позволяет писать тесты, которые требуют выполнения транзакций.
    - Не оборачивает каждый тест в транзакцию, а позволяет тестам управлять транзакциями вручную.
3. **SimpleTestCase:**
    - Наследуется от `unittest.TestCase`.
    - Не использует тестовую базу данных.
    - Подходит для тестов, не требующих работы с базой данных.
4. **Client:**
    - Имитация клиента веб-браузера.
    - Позволяет отправлять запросы к вашему приложению и проверять ответы.
    - Полезен для тестирования представлений и маршрутов (URL).
5. **RequestFactory:**
    - Создает объекты запросов, которые можно использовать для тестирования представлений на более низком уровне.
    - Не выполняет весь цикл запроса, а только создает объект запроса.

### TestCase

Класс `TestCase` в Django предоставляет функциональность для написания и выполнения тестов с использованием транзакций для изоляции данных между тестами. Это позволяет тестам быть независимыми друг от друга и предотвращает побочные эффекты.

`TestCase` наследуется от `TransactionTestCase`, но использует `transaction.atomic()` для изоляции тестов, что делает выполнение тестов быстрее в большинстве случаев. На базах данных, не поддерживающих транзакции, `TestCase` ведет себя как `TransactionTestCase`.

Для создания тестов, нам нужно наследоваться от класса `TestCase`. Например,

```Python
class GetPagesTestCase(TestCase):
    def test_mainpage(self):
        path = reverse('home')
        response = self.client.get(path)
        self.assertEqual(response.status_code, 200)
        self.assertIn('women/index.html', response.template_name)
        self.assertEqual(response.context_data['title'], 'Главная страница')
```

Все методы, начинающиеся с `test_`, будут автоматически обнаружены и выполнены тестовым фреймворком.

**Методы для настройки и очистки данных:**

- **setUpTestData(cls):**
    
    Метод класса, который вызывается один раз перед запуском всех тестов в классе. Используется для установки данных, которые будут использоваться всеми тестами.
    
    **Кейсы использования:**
    
    - Создание тестовых данных, которые не будут изменяться в процессе выполнения тестов. Например, создание пользователей, статей, категорий и других объектов, которые требуются для всех тестов в классе.
    - Установка начальных значений для постоянных данных, таких как конфигурации или настройки.
    
- **setUp(self):**
    
    Метод, который вызывается перед каждым тестом. Используется для настройки состояния, необходимого для выполнения каждого отдельного теста.
    
    **Кейсы использования:**
    
    - Инициализация объектов, которые могут изменяться от теста к тесту, например, создание клиентских сессий или установка специфических параметров.
    - Подготовка временных данных или контекста для каждого теста, таких как временные файлы или директории.
    
- **tearDown(self):**
    
    Метод, который вызывается после каждого теста. Используется для очистки состояния после выполнения каждого теста.
    
    **Кейсы использования:**
    
    - Удаление временных данных или файлов, созданных в процессе теста, чтобы они не влияли на последующие тесты.
    - Очистка кэша или сброс состояния, если тесты могут изменять глобальные параметры или состояния.
    

**Пример с использованием всех методов:**

```Python
from django.test import TestCase
from django.core.cache import cache
from django.contrib.auth.models import User
from .models import Article

class BlogTestCase(TestCase):

    @classmethod
    def setUpTestData(cls):
        # Создание пользователя и статей для всех тестов
        cls.user = User.objects.create_user(username='testuser', password='password')
        cls.article1 = Article.objects.create(title='Article 1', author=cls.user)
        cls.article2 = Article.objects.create(title='Article 2', author=cls.user)

    def setUp(self):
        # Инициализация клиента и логин пользователя перед каждым тестом
        self.client = Client()
        self.client.login(username='testuser', password='password')

    def tearDown(self):
        # Очистка кэша после каждого теста
        cache.clear()

    def test_article_list_view(self):
        # Тест представления списка статей
        response = self.client.get('/articles/')
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Article 1')
        self.assertContains(response, 'Article 2')

    def test_article_detail_view(self):
        # Тест представления детали статьи
        response = self.client.get(f'/articles/{self.article1.id}/')
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Article 1')
```

<div class="page-break" style="page-break-before: always;"></div>
