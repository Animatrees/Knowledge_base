Описание

BaseBackend

ModelBackend

Создание пользовательского бэкенда аутентификации

### Описание

**Бэкенды аутентификации** - это классы, которые определяют, как происходит аутентификация пользователей в приложении. Они отвечают за проверку предоставленных учетных данных (например, имени пользователя и пароля) и возвращают соответствующий объект пользователя, если учетные данные действительны.

**Настройка бэкендов аутентификации:**

- В файле `settings.py` проекта Django есть настройка `AUTHENTICATION_BACKENDS`, которая определяет список классов бэкендов аутентификации, используемых в проекте.
- По умолчанию Django использует бэкенд `django.contrib.auth.backends.ModelBackend`, который выполняет аутентификацию на основе модели пользователя Django.
- Можно добавить собственные классы бэкендов аутентификации в список `AUTHENTICATION_BACKENDS`, чтобы расширить или изменить поведение аутентификации.
- Django будет использовать бэкенды аутентификации в указанном порядке, пока не будет найден подходящий объект пользователя.

### BaseBackend

Класс `BaseBackend` является базовым классом для всех бэкендов аутентификации в Django и предоставляет реализации по умолчанию для всех необходимых методов.

По сути это скорее абстрактный класс, который предоставляет общий интерфейс и структуру для бэкендов аутентификации в Django. Он **не предназначен для непосредственного использования**, так как не реализует конкретную логику аутентификации.

Основная цель `BaseBackend` - определить набор методов, которые должны быть реализованы в конкретных бэкендах аутентификации. Он предоставляет реализации по умолчанию для этих методов, но они, как правило, не выполняют фактическую аутентификацию и авторизацию, а просто возвращают значения по умолчанию (например, `None` или пустое множество).

При создании собственных бэкендов аутентификации разработчики должны наследоваться от класса `BaseBackend` и переопределять соответствующие методы, такие как `authenticate()`, `get_user()`, `get_user_permissions()` и т.д., в соответствии с конкретными требованиями аутентификации и авторизации.

**Методы:**

- `authenticate(self, request, **kwargs)`:
    - Этот метод является основным методом аутентификации и должен быть переопределен в каждом конкретном бэкенде аутентификации.
    - Он принимает объект запроса (`request`) и произвольные именованные аргументы (`*kwargs`), которые могут содержать учетные данные для аутентификации (например, имя пользователя и пароль).
    - Реализация по умолчанию в `BaseBackend` всегда возвращает `None`, что означает, что аутентификация не удалась.
- `get_user(self, user_id)`:
    - Этот метод используется для получения объекта пользователя по его идентификатору (`user_id`).
    - Реализация по умолчанию в `BaseBackend` всегда возвращает `None`, что означает, что пользователь не найден.
    - Конкретные бэкенды аутентификации должны переопределить этот метод, чтобы возвращать соответствующий объект пользователя на основе предоставленного идентификатора.
- `get_user_permissions(self, user_obj, obj=None)`:
    - Этот метод возвращает множество строк разрешений, которые имеет пользователь `user_obj` для указанного объекта `obj` (если он предоставлен).
    - Реализация по умолчанию в `BaseBackend` всегда возвращает пустое множество, что означает, что пользователь не имеет никаких специальных разрешений.
- `get_group_permissions(self, user_obj, obj=None)`:
    - Этот метод возвращает множество строк разрешений, которые имеет пользователь `user_obj` на основе групп, к которым он принадлежит, для указанного объекта `obj` (если он предоставлен).
    - Реализация по умолчанию в `BaseBackend` всегда возвращает пустое множество, что означает, что пользователь не имеет никаких разрешений на основе групп.
- `get_all_permissions(self, user_obj, obj=None)`:
    - Этот метод объединяет разрешения, полученные из `get_user_permissions()` и `get_group_permissions()`, и возвращает общее множество строк разрешений, которые имеет пользователь `user_obj` для указанного объекта `obj` (если он предоставлен).
    - Реализация по умолчанию в `BaseBackend` использует операцию объединения множеств (`*`) для объединения разрешений пользователя и групп.
- `has_perm(self, user_obj, perm, obj=None)`:
    - Этот метод проверяет, имеет ли пользователь `user_obj` указанное разрешение `perm` для указанного объекта `obj` (если он предоставлен).
    - Реализация по умолчанию в `BaseBackend` использует `get_all_permissions()` для получения всех разрешений пользователя и проверяет, содержится ли `perm` в этом множестве.

### ModelBackend

Класс `ModelBackend` играет ключевую роль в процессе аутентификации и управления разрешениями в Django. Он наследуется от класса `BaseBackend` и предоставляет набор методов, которые позволяют проверять учетные данные пользователей, получать информацию об их разрешениях и проверять, имеет ли пользователь определенное разрешение.

Интересной особенностью `ModelBackend` является то, что он учитывает состояние активности пользователя. Если пользователь неактивен (поле `is_active` равно `False`), методы получения разрешений возвращают пустые множества, а метод `has_perm()`, который проверяет наличие определенного разрешения у пользователя, возвращает `False`. Это позволяет легко отключать доступ для неактивных пользователей без необходимости удалять их из системы.

**Методы:**

- `authenticate(request, username=None, password=None, **kwargs)`:
    - Этот метод выполняет аутентификацию пользователя на основе предоставленных учетных данных (имени пользователя и пароля).
    - Если `username` не указано, метод пытается получить имя пользователя из `kwargs` с использованием ключа `USERNAME_FIELD` модели пользователя.
    - Метод пытается получить пользователя с указанным именем пользователя с помощью `UserModel._default_manager.get_by_natural_key(username)`.
    - Если пользователь найден, метод проверяет пароль с помощью `user.check_password(password)` и проверяет, может ли пользователь аутентифицироваться с помощью `user_can_authenticate(user)` - активен ли пользователь?
    - Если аутентификация успешна, метод возвращает аутентифицированного пользователя. В противном случае возвращается `None`.
- `get_user(user_id)`
    - Этот метод получает объект пользователя по его идентификатору (`user_id`).
    - Он пытается найти пользователя в базе данных, используя `UserModel._default_manager.get(pk=user_id)`, где `UserModel` - это модель пользователя, настроенная в Django.
    - Если пользователь с указанным `user_id` не найден, метод возвращает `None`.
    - Если пользователь найден, метод проверяет, может ли пользователь аутентифицироваться, используя метод `user_can_authenticate(user)`. Этот метод проверяет, активен ли пользователь (`is_active=True`).
    - Если пользователь может аутентифицироваться, метод возвращает объект пользователя. В противном случае возвращается `None`.
- `get_user_permissions(user_obj, obj=None)`:
    - Этот метод возвращает множество строк разрешений, которые пользователь `user_obj` имеет на основе собственных разрешений пользователя.
    - Если `user_obj` анонимный или неактивный, метод возвращает пустое множество.
- `get_group_permissions(user_obj, obj=None)`:
    - Этот метод возвращает множество строк разрешений, которые пользователь `user_obj` имеет на основе разрешений групп, к которым он принадлежит.
    - Если `user_obj` анонимный или неактивный, метод возвращает пустое множество.
- `get_all_permissions(user_obj, obj=None)`:
    - Этот метод возвращает объединенное множество строк разрешений, которые пользователь `user_obj` имеет, включая как собственные разрешения пользователя, так и разрешения групп.
    - Если `user_obj` анонимный или неактивный, метод возвращает пустое множество.
- `has_perm(user_obj, perm, obj=None)`:
    - Этот метод проверяет, имеет ли пользователь `user_obj` указанное разрешение `perm`.
    - Он использует `get_all_permissions()` для получения всех разрешений пользователя и проверяет наличие `perm` в этом множестве.
    - Если пользователь неактивный, метод возвращает `False`.
- `user_can_authenticate(user)`:
    - Этот метод определяет, может ли пользователь `user` аутентифицироваться.
    - Он проверяет атрибут `is_active` пользователя и возвращает `True`, если пользователь активен, или `False`, если пользователь неактивен.
    - Для пользовательских моделей пользователей, у которых нет атрибута `is_active`, метод возвращает `True`.
- `with_perm(perm, is_active=True, include_superusers=True, obj=None)`:
    - Этот метод возвращает queryset активных пользователей, которые имеют указанное разрешение `perm`.
    - `perm` может быть либо в формате `"<app label>.<permission codename>"`, либо экземпляром `Permission`.
    - Если `is_active` равно `True` (по умолчанию), метод возвращает только активных пользователей. Если `False`, метод возвращает только неактивных пользователей. Если `None`, метод возвращает всех пользователей независимо от их активности.
    - Если `include_superusers` равно `True` (по умолчанию), результат будет включать суперпользователей.

### Создание пользовательского бэкенда аутентификации

Для создания пользовательского бэкенда аутентификации нужно создать класс, который наследуется от `BaseBackend` или любого другого существующего бэкенда аутентификации.

Если вам нужна только кастомная логика аутентификации, но вы хотите сохранить функциональность разрешений и групп из `ModelBackend`, то вы можете создать свой бэкенд, унаследовавшись от `BaseBackend`, и указать оба бэкенда в `AUTHENTICATION_BACKENDS`. Django будет использовать вашу кастомную аутентификацию и разрешения из `ModelBackend`.

Если же вам нужен полный контроль над процессом аутентификации и авторизации, и вы не хотите использовать функциональность `ModelBackend`, то лучше наследоваться от `BaseBackend`, реализовать все необходимые методы самостоятельно и не указывать `ModelBackend` в `AUTHENTICATION_BACKENDS`.

Для создания пользовательского бэкенда в классе нужно переопределить методы `authenticate` и `get_user` в соответствии с требуемой логикой аутентификации.

**Пример реализации аутентификации через email:**

1. В приложении `users` создаём файл, в котором будем прописывать свою логику, например - `authentication.py`.
2. В нём создаём класс, который наследуется от `BaseBackend`, но определяет свои методы `authenticate` и `get_user`.
    
    ```Python
    from django.contrib.auth.backends import BaseBackend
    from django.contrib.auth import get_user_model
     
     
    class EmailAuthBackend(BaseBackend):
        def authenticate(self, request, username=None, password=None, **kwargs):
            user_model = get_user_model()
            try:
                user = user_model.objects.get(email=username)
                if user.check_password(password):
                    return user
                return None
            # если пользователь с указанным email не найден 
            # или найдено больше одного совпадения с email
            # пользователь не будет аутентифицирован
            except (user_model.DoesNotExist, user_model.MultipleObjectsReturned):
                return None
                
     def get_user(self, user_id):
            user_model = get_user_model()
            try:
                return user_model.objects.get(pk=user_id)
            except user_model.DoesNotExist:
                return None
    ```
    
3. В файле `settings.py` явно прописываем константу AUTHENTICATION_BACKENDS и добавляем наш кастомный бэкенд в список.
    
    ```Python
    AUTHENTICATION_BACKENDS = [
        'django.contrib.auth.backends.ModelBackend',
        'users.authentication.EmailAuthBackend',
    ]
    ```
    

> [!important]  
> Важно помнить, что при таком подходе у пользователя сохраняется возможность аутентификации по username, а также, что в нашей кастомной реализации при аутентификации по email не будет выполнена проверка активности пользователя.

<div class="page-break" style="page-break-before: always;"></div>
