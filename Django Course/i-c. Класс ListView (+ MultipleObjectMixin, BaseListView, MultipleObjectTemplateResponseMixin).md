Описание

Наследование

MultipleObjectMixin

BaseListView

MultipleObjectTemplateResponseMixin

Краткое summery

### Описание

**ListView** - это один из самых мощных и гибких классов в фреймворке Django, который позволяет легко создавать представления, отображающие список объектов из базы данных. Этот класс является частью пакета `django.views.generic`, который предоставляет набор готовых генерических представлений, упрощающих разработку веб-приложений.

Благодаря наследованию от целого ряда базовых классов, таких как `MultipleObjectMixin`, `TemplateResponseMixin` и `ContextMixin`, `ListView` предоставляет богатый набор возможностей "из коробки":

- Автоматическое получение queryset из указанной модели.
- Постраничный вывод списка с гибкой настройкой пагинации.
- Формирование контекста для шаблона с учетом пагинации и других параметров.
- Автоматическое определение имени шаблона на основе модели.

Разработчики могут быстро создавать представления, отображающие списки, сосредоточившись на реализации бизнес-логики, а не на рутинных задачах, связанных с обработкой коллекций объектов.

Кроме того, гибкость `ListView` позволяет легко расширять или переопределять его поведение в зависимости от требований проекта. Переопределение методов, таких как `get_queryset()` и `get_context_data()`, дает возможность адаптировать представление под конкретные нужды.

**Наследуемся от класса ListView для отображения постов по категориям:**

```Python
class ShowCatsView(ListView):
    template_name = 'basefunc/index.html'
    context_object_name = 'posts'

    def get_queryset(self):
        return POSTS.filter(cat__slug=self.kwargs['cat_slug'])

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        category = get_object_or_404(Category, slug=self.kwargs['cat_slug'])
        context.update({'title': category.title, 'cat_id': category.pk})
        if not context['posts']:
            context['empty_list_message'] = 'Нет женщин в данной категории.'
        return context
```

### Наследование

- **MultipleObjectTemplateResponseMixin:** Расширяет функциональность `TemplateResponseMixin` для работы со списками объектов. Определяет дополнительные атрибуты и методы, связанные с пагинацией и выводом списка в шаблоне.
    - наследуется от [[i-b. Классы TemplateView, ContextMixin, TemplateResponseMixin]]: предоставляет возможность использования шаблонов HTML для генерации HTTP-ответа. Он добавляет метод `render_to_response()`, который загружает указанный шаблон и передает контекст в него для генерации ответа.
- **BaseListView:** объединяет функциональность `MultipleObjectMixin` и `ContextMixin`, связывает данные из `MultipleObjectMixin` с контекстом шаблона.
    - наследуется от **MultipleObjectMixin**: добавляет поддержку работы со списком объектов. Предоставляет атрибуты и методы для настройки выборки, сортировки, фильтрации и пагинации списка объектов. Определяет метод `get_queryset()`, который можно переопределять для получения необходимых объектов.
        - наследуется от [[i-b. Классы TemplateView, ContextMixin, TemplateResponseMixin]]**:** предоставляет возможность добавления дополнительного контекста к HTTP-ответу. Добавляет метод `get_context_data()`, который позволяет определить контекстные данные для передачи в шаблон.
    - [[i-a. Базовый класс представлений - View]]**:** является базовым для всех представлений в Django. Он предоставляет основную функциональность для обработки HTTP-запросов и генерации HTTP-ответов.

Рассмотрим доступные для класса ListView атрибуты и методы, через классы от которых он наследуется.

### MultipleObjectMixin

Класс `MultipleObjectMixin` предоставляет обширную функциональность для работы с несколькими объектами в представлениях Django.

**Атрибуты:**

- `queryset`: Указывает начальный набор объектов для отображения. Может быть экземпляром `QuerySet`. Если указано, значение queryset заменяет значение, указанное для model.
- `model`: Модель Django, объекты которой будут отображаться в списке. Указание `model = Post` фактически равнозначно указанию `queryset = Post.objects.all()`.
- `context_object_name`: Имя переменной в контексте шаблона, в которой будет передан список объектов. Если не прописывать это имя, то queryset будет доступен в шаблоне по имени `object_list`. Переменная `object_list` остаётся доступной, даже если указать кастомное имя для списка объектов. И по сути, указывая своё имя, мы дублируем список объектов в контексте.
- `ordering`: Поле(я) для сортировки queryset.
- `allow_empty`: Булево значение, указывающее, отображать ли страницу, если нет доступных объектов. Если это значение равно False и ни один объект не доступен, то вместо отображения пустой страницы представление выдаст сообщение 404. По умолчанию это значение равно True.
- `paginate_by`: Количество объектов на одной странице при постраничном выводе.
- `paginate_orphans`: Определяет минимальное количество объектов, которые должны быть отображены на последней странице, чтобы избежать "сирот" (последняя страница слишком маленькая).
- `paginator_class`: Класс пагинатора, используемый для разбиения списка на страницы. По умолчанию класс Paginator.
- `page_kwarg`: Это атрибут, который определяет имя параметра в URL, используемого для указания номера страницы при пагинации. По умолчанию “page”.

**Методы** (используются вместо атрибутов, когда нужна более сложная логика или обработка динамических параметров)**:**

- `get_queryset()`: Возвращает queryset для отображения. Если `queryset` или `model` не заданы, метод генерирует ошибку.
- `get_ordering()`: Возвращает поля для сортировки queryset.
- `paginate_queryset()`: Разбивает queryset на страницы и возвращает кортеж с пагинатором, текущей страницей, списком объектов на странице и флагом, указывающим, есть ли другие страницы.
- `get_paginate_by()`: Возвращает количество объектов на странице.
- `get_paginator()`: Возвращает экземпляр пагинатора с заданными параметрами.
- `get_paginate_orphans()`: Возвращает максимальное количество "осиротевших" объектов.
- `get_allow_empty()`: Возвращает True, если нужно выводить пустой список, False, если нужно генерировать 404.
- `get_context_object_name()`: Возвращает имя переменной в контексте шаблона, в которой будет передан список объектов.

- `get_context_data(self, *, object_list=None, **kwargs)`: Формирует контекст для шаблона, в том числе добавляя переменные, связанные с постраничным выводом.
    
    Основное отличие `MultipleObjectMixin.get_context_data()` от `ContextMixin.get_context_data()` в том, что он более сложный и предоставляет дополнительные данные, связанные с постраничным выводом списка объектов (пагинатор, текущая страница, флаг пагинации), в то время как `ContextMixin.get_context_data()` просто копирует все переданные ключевые аргументы в контекст.
    
    **Этот метод делает следующее:**
    
    1. Получает набор объектов (`queryset`) либо из переданного аргумента `object_list`, либо из `self.object_list`.
    2. Определяет количество объектов на странице (`page_size`) и имя переменной в контексте, где будет передан список объектов (`context_object_name`).
    3. Если включена пагинация, инициализирует пагинатор, текущую страницу и формирует соответствующие данные для контекста.
    4. Добавляет в контекст переменную с именем, определенным в `context_object_name`, содержащую список объектов.
    5. Обновляет контекст дополнительными ключевыми аргументами, переданными в метод.
    6. Вызывает `super().get_context_data()`, чтобы позволить `ContextMixin` добавить свои данные в контекст.

### BaseListView

`BaseListView` является основным классом для представлений, которые отображают список объектов. Он наследует функциональность от `MultipleObjectMixin` и `View`. В самом классе реализован только метод get, который запускает необходимую логику для работы `ListView`.

**Рассмотрим, что происходит в методе** **`get()`** **этого класса:**

1. В начале метода вызывается `self.get_queryset()`, чтобы получить набор объектов, которые будут отображаться в списке, и сохраняется в `self.object_list`.
2. Далее вызывается `self.get_allow_empty()`, чтобы проверить, нужно ли выводить пустой список, если в `self.object_list` нет объектов.
3. Если `allow_empty` равен `False` (то есть пустой список не допускается), то проверяется, действительно ли `self.object_list` пуст:
    - Если пагинация включена и `self.object_list` является `QuerySet`, то выполняется проверка на наличие объектов с помощью метода `exists()`.
    - Если пагинация выключена или `self.object_list` не является `QuerySet`, то проверка выполняется просто на пустоту `self.object_list`.
    - Если список пуст, то генерируется исключение `Http404` с соответствующим сообщением.
4. После проверки на пустоту, вызывается `self.get_context_data()`, чтобы получить контекст для рендеринга шаблона.
5. Наконец, вызывается `self.render_to_response(context)`, чтобы отрендерить шаблон с подготовленным контекстом.

Таким образом, `BaseListView` реализует основную логику обработки GET-запросов для представлений, отображающих списки объектов. Он проверяет, разрешено ли выводить пустой список, формирует контекст для шаблона на основе `MultipleObjectMixin` и возвращает отрендеренный ответ.

### **MultipleObjectTemplateResponseMixin**

`MultipleObjectTemplateResponseMixin` является миксином, который расширяет функциональность `TemplateResponseMixin` для работы с представлениями, отображающими списки объектов. Реализует только дополнительную логику для метода - `get_template_names()`.

**Рассмотрим, что происходит внутри метода** **`get_template_names()`****:**

1. Сначала вызывается `super().get_template_names()`, чтобы получить список имен шаблонов, определенных в базовых классах. Если `template_name` не задан, будет вызвано исключение `ImproperlyConfigured`, и список имен шаблонов будет пустым.
2. Если `self.object_list` имеет атрибут `model`, то это означает, что он является `QuerySet`. В этом случае, миксин пытается сконструировать имя шаблона на основе имени модели и приложения. Это имя добавляется в конец списка, чтобы пользовательские имена шаблонов имели более высокий приоритет. Например, если `self.object_list` является `QuerySet` модели `MyModel` из приложения `myapp`, то будет добавлено имя шаблона `"myapp/mymodel_list.html"`.
3. Если после вызова `super().get_template_names()` список имен шаблонов все еще пуст, то генерируется исключение `ImproperlyConfigured`, так как `MultipleObjectTemplateResponseMixin` требует, чтобы либо был задан атрибут `template_name`, либо `get_queryset()` возвращал `QuerySet`.
4. Наконец, метод возвращает список имен шаблонов, который будет использован для рендеринга ответа.

Основная цель `MultipleObjectTemplateResponseMixin` - автоматически сконструировать имя шаблона на основе модели, если оно не было явно задано. Это упрощает использование представлений, отображающих списки объектов, так как разработчику не нужно вручную определять имя шаблона в большинстве случаев.

### Краткое summery

1. `queryset` - указывает начальный набор объектов для отображения. Может быть экземпляром `QuerySet`. Если указано, значение `queryset` заменяет значение, указанное для `model`. Позволяет явно задать набор объектов, которые будут отображаться в списке.
2. `model` - модель Django, объекты которой будут отображаться в списке. Указание `model = Post` фактически равнозначно указанию `queryset = Post.objects.all()`. Используется, если не задан `queryset`, для автоматического получения всех объектов модели.
3. `context_object_name` - имя переменной в контексте шаблона, в которой будет передан список объектов. Если не указано, то queryset будет доступен в шаблоне по имени `object_list`. Позволяет задать более осмысленное имя для списка объектов в шаблоне.
4. `paginate_by` - количество объектов на одной странице при постраничном выводе. Если указано, ListView будет автоматически разбивать список объектов на страницы.
5. `allow_empty` - булево значение, указывающее, отображать ли страницу, если нет доступных объектов. Если значение равно `False` и ни один объект не доступен, то вместо отображения пустой страницы представление выдаст сообщение 404. По умолчанию равно `True`.
6. `get_queryset()` - метод, который возвращает queryset для отображения. Если `queryset` или `model` не заданы, метод генерирует ошибку. Позволяет переопределить логику получения объектов, например, для фильтрации или сортировки.
7. `get_context_data(**kwargs)` - метод, который формирует контекст для шаблона, в том числе добавляя переменные, связанные с постраничным выводом. Позволяет добавлять дополнительные данные в контекст шаблона.
8. `paginate_queryset(queryset, page_size)` - метод, который разбивает queryset на страницы и возвращает кортеж с пагинатором, текущей страницей, списком объектов на странице и флагом, указывающим, есть ли другие страницы. Можно переопределить для изменения логики пагинации.
9. `get_template_names()` - метод, который возвращает список имен шаблонов для рендеринга. По умолчанию пытается автоматически определить имя шаблона на основе имени модели и приложения, если `template_name` не задан явно.
10. `render_to_response(context, **response_kwargs)` - метод, который рендерит шаблон с указанным контекстом и возвращает HTTP-ответ. Можно переопределить для изменения логики рендеринга или добавления дополнительных параметров ответа.

Переопределение методов, таких как `get_queryset()`, `get_context_data()` и `get_template_names()`, дает возможность адаптировать ListView под конкретные требования проекта. Например, можно реализовать фильтрацию и сортировку списка объектов, добавить дополнительные данные в контекст или изменить логику выбора шаблона.

<div class="page-break" style="page-break-before: always;"></div>
