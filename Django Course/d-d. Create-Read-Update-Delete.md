Ещё раз про модели и их экземпляры

Менеджер объектов - Model.objects

Create

Объект connection

Read

get_object_or_404()

Lookups

class Meta

Update

Delete

### Ещё раз про модели и их экземпляры

**Класс модели** в Django представляет собой **описание структуры данных** для создания таблиц в базе данных. Этот класс определяет поля (атрибуты), которые будут присутствовать в таблице, а также любые связи с другими моделями. Каждый класс модели является подклассом `django.db.models.Model`.

**Экземпляр класса модели** представляет собой **конкретную запись в таблице** базы данных, которая соответствует этой модели. Каждый экземпляр класса модели представляет отдельную строку в таблице, а атрибуты экземпляра соответствуют значениям полей этой строки.

В Django модели являются "**ленивыми**" в том смысле, что их определение выполняется в момент обращения к ним, а не при первоначальной загрузке кода. Это означает, что Django не создает или не загружает модели в память до тех пор, пока они не понадобятся во время выполнения приложения.

Этот подход имеет несколько преимуществ:

1. **Эффективное использование ресурсов:** Приложение Django загружает только те модели, которые действительно необходимы для обработки текущего запроса или операции. Это позволяет снизить нагрузку на память и процессор, особенно при работе с большим количеством моделей в крупных приложениях.
2. **Быстрая инициализация:** Загрузка моделей происходит только в том случае, если они действительно используются. Это может ускорить время инициализации приложения, особенно если в проекте много моделей.
3. **Гибкость в управлении кодом:** Поскольку модели загружаются только по мере необходимости, это обеспечивает гибкость в управлении кодом и его организации. Вы можете создавать множество моделей, не беспокоясь о негативном влиянии на производительность, поскольку они не будут загружены, пока не будут использованы.

### Менеджер объектов - Model.objects

Каждая модель Django имеет по умолчанию свой собственный менеджер объектов, доступный через атрибут `objects`. Обычно он называется `ModelName.objects`, где `ModelName` - это название модели. Этот менеджер объектов предоставляет набор методов для выполнения операций с объектами данной модели, таких как создание, извлечение, фильтрация, обновление и удаление.

**Некоторые основные методы, доступные через менеджер объектов:**

1. `all()`: Возвращает все объекты модели.
2. `get()`: Возвращает один объект, соответствующий указанным условиям.
3. `filter()`: Возвращает набор объектов, отфильтрованных по указанным условиям.
4. `exclude()`: Возвращает набор объектов, исключая те, которые соответствуют указанным условиям.
5. `create()`: Создает новый объект модели и сохраняет его в базе данных.
6. `update()`: Обновляет существующие объекты, соответствующие указанным условиям.

Менеджер объектов также позволяет определять пользовательские методы запроса, которые могут быть вызваны из кода приложения для выполнения более сложных запросов к базе данных.

> [!important]  
> Менеджеры доступны только через классы моделей, а не из экземпляров моделей, чтобы обеспечить разделение между операциями на уровне таблиц и операциями на уровне записей.  

### Create

Есть несколько способов добавить данные в таблицу БД:

1. **Создание и сохранение экземпляров модели:**
    - В терминале открываем Django shell (или улучшенную shell_plus), если используем стандартную оболочку, то нужно импортировать в неё класс модели, объект которой мы планируем создать.
    - Создаём объект класса.
    - Сохраняем его в базе данных с помощью метода `save()`.
        
        ```Shell
        from myapp.models import MyModel
        
        # Создание экземпляра модели
        obj = MyModel(field1='value1', field2='value2')
        
        # Сохранение экземпляра в базе данных
        obj.save()
        ```
        
2. **Массовое добавление данных с использованием метода** `bulk_create()`**:**
    - Можно использовать метод `bulk_create()` для массового добавления объектов модели (в данном способе первый пункт аналогичен предыдущему)
        
        ```Shell
        from myapp.models import MyModel
        
        MyModel.objects.bulk_create([
            MyModel(field1='value1', field2='value2'),
            MyModel(field1='value3', field2='value4'),
            # Другие объекты...
        ])
        ```
        
3. **Использование метода** `create()` **менеджера объектов:**
    - Метод `create()` позволяет создать и сохранить экземпляр модели в одном вызове.
        
        ```Shell
        from myapp.models import MyModel
        
        MyModel.objects.create(field1='value1', field2='value2')
        ```
        

Также все эти команды можно прописывать в отдельных python-скриптах и выполнять, для более автоматизированного добавления данных в таблицу.

**Просмотр значений полей**

Для каждого созданного объекта можно получить доступ к его полям через атрибуты объекта. Например, атрибут - `pk` (primary key) универсален для всех объектов и будет содержать в себе идентификатор объекта (обычно то же, что сохраняется в поле id) - `obj.pk` или `obj.id`

### Объект connection

`connection` из модуля `django.db` представляет собой объект, который предоставляет **доступ к текущему соединению** с базой данных. Он используется для выполнения запросов к базе данных и управления соединением. Вот несколько ключевых аспектов объекта `connection`:

1. **Атрибут** `queries`:
    - Атрибут `queries` объекта `connection` представляет собой список всех выполненных SQL-запросов в текущей сессии. Каждый элемент списка содержит словарь с информацией о выполненном запросе, включая сам запрос, время выполнения и другие метаданные.
        
        Для того, чтобы вывод был не в одну строку, а красиво отформатирован, используйте pprint - pretty print)
        
        ```Shell
        In [2]: from django.db import connection
        
        In [3]: from pprint import pprint
        
        In [4]: pprint(connection.queries)
        [{'sql': 'BEGIN', 'time': '0.000'},
         {'sql': 'INSERT INTO "basefunc_posts" ("title", "content", "time_create", '
                 '"time_update", "is_published") VALUES (\'Моя первая статья\', '
                 "'Содержание первой статьи', '2024-02-26 19:13:11.152907', "
                 "'2024-02-26 19:13:11.152981', 1), ('Моя вторая статья', 'Содержание "
                 "второй статьи', '2024-02-26 19:13:11.153028', '2024-02-26 "
                 '19:13:11.153053\', 1) RETURNING "basefunc_posts"."id"',
          'time': '0.001'},
         {'sql': 'ROLLBACK', 'time': '0.000'},
         {'sql': 'BEGIN', 'time': '0.000'},
         {'sql': 'INSERT INTO "basefunc_posts" ("title", "content", "time_create", '
                 '"time_update", "is_published") VALUES (\'Моя первая статья\', '
                 "'Содержание первой статьи', '2024-02-26 19:15:10.095581', "
                 "'2024-02-26 19:15:10.095633', 1), ('Моя вторая статья', 'Содержание "
                 "второй статьи', '2024-02-26 19:15:10.095675', '2024-02-26 "
                 '19:15:10.095699\', 1) RETURNING "basefunc_posts"."id"',
          'time': '0.001'},
         {'sql': 'COMMIT', 'time': '0.005'},
         {'sql': 'INSERT INTO "basefunc_posts" ("title", "content", "time_create", '
                 '"time_update", "is_published") VALUES (\'Моя третья статья\', '
                 "'Содержание третьей статьи', '2024-02-26 19:19:07.019531', "
                 '\'2024-02-26 19:19:07.019570\', 1) RETURNING "basefunc_posts"."id"',
          'time': '0.001'}]
        ```
        
2. **Выполнение запросов:**
    - `connection` позволяет выполнять SQL-запросы напрямую к базе данных с помощью методов `cursor()` и `execute()`. Это может быть полезно, если вам нужно выполнить сложный запрос, который нельзя выполнить с помощью ORM Django.
3. **Управление транзакциями:**
    - `connection` позволяет начинать, фиксировать и откатывать транзакции с помощью методов `begin()`, `commit()` и `rollback()`. Это полезно, если вам нужно управлять транзакциями вручную.
4. **Настройка соединения:**
    - `connection` предоставляет доступ к настройкам соединения с базой данных, таким как уровень изоляции транзакций, автозавершение транзакций и другие параметры.

### Read

Менеджер объектов предоставляет следующие методы для доступа к объектам в базе данных:

1. **all():**
    - Метод `all()` возвращает все объекты модели в виде QuerySet (коллекция объектов из базы данных). Он эквивалентен SQL-запросу `SELECT * FROM <table>`, где `<table>` - имя таблицы, связанной с моделью.
        
        ```Python
        all_objects = MyModel.objects.all()
        ```
        
    - Для all() можно указать индекс или срез, чтобы ограничить QuerySet определенным количеством результатов. Это эквивалент `LIMIT` и `OFFSET` в SQL.
        
        ```Python
        MyModel.objects.all()[:5]
        ```
        
2. **filter():**
    - Метод `filter()` возвращает набор объектов, отфильтрованных по указанным условиям. Он эквивалентен `WHERE` в SQL.  
        Условия указываются в виде именованных аргументов (**kwargs), где имя аргумента соответствует имени поля, а значение - желаемому значению поля.  
        Этот метод всегда возвращает QuerySet, даже если после применения условия для вывода останется один объект из таблицы (или если не останется ничего, тогда мы получим пустой QuerySet).  
        
        ```Python
        filtered_objects = MyModel.objects.filter(field1=value1, field2=value2)
        ```
        
3. **exclude():**
    
    - Метод `exclude()` возвращает набор объектов, исключая те, которые соответствуют указанным условиям. Он эквивалентен `WHERE NOT` в SQL.  
        Условия указываются так же, как и в методе  
        `filter()`.
        
        ```Python
        excluded_objects = MyModel.objects.exclude(field1=value1)
        ```
        
    
    > [!important]  
    > Можно образовывать цепочки вызовов из предыдущих двух методов. Например: Entry.objects.filter(headline__startswith="What").exclude(  
    ... pub_date__gte=datetime.date.today()  
    ...).filter(pub_date__gte=datetime.date(2005, 1, 30))  
    
4. **get():**
    - Метод `get()` возвращает один объект, соответствующий указанным условиям. Если найдено более одного объекта или ни одного объекта, выбрасывается исключение `MultipleObjectsReturned` или `DoesNotExist` соответственно.  
        Как и метод  
        `filter()` использует `WHERE` в SQL, но возвращает только один конкретный объект (или вызывает исключение, если кол-во объектов не равно 1).
        
        ```Python
        my_object = MyModel.objects.get(id=1)
        ```
        
5. **order_by():**
    - Используется для сортировки результатов запроса к базе данных по заданному или нескольким полям. Этот метод позволяет упорядочить объекты модели в результирующем наборе данных по определенному критерию. Аналогичен `ORDER_BY` в SQL.
        
        ```Python
        # Сортировка по полю "name" по возрастанию
        MyModel.objects.order_by('name')
        
        # Сортировка по полю "date_created" по убыванию
        MyModel.objects.order_by('-date_created')
        
        # Сортировка по нескольким полям: "category" по возрастанию, а затем "price" по убыванию
        MyModel.objects.order_by('category', '-price')
        ```
        

### get_object_or_404()

Функция `get_object_or_404` из модуля `django.shortcuts` предназначена для получения объекта из базы данных по заданным критериям, и если объект не найден, то она автоматически генерирует исключение `Http404`.

**Синтаксис**:

```Python
get_object_or_404(klass, *args, **kwargs)
```

- `klass`: Класс модели, менеджер или экземпляр запроса QuerySet, из которого нужно получить объект.
- `args`: Объекты Q.
- `*kwargs`: Параметры поиска, которые принимаются методами `get()` и `filter()`.

**Пример использования:**

```Python
from django.shortcuts import get_object_or_404

def my_view(request):
    obj = get_object_or_404(MyModel, pk=1)
```

**Аргументы**:

- Чаще всего используется передача класса модели, как показано выше. Однако можно также передать экземпляр запроса QuerySet:
    
    ```Python
    queryset = Book.objects.filter(title__startswith="M")
    get_object_or_404(queryset, pk=1)
    ```
    
    Этот пример эквивалентен:
    
    ```Python
    get_object_or_404(Book, title__startswith="M", pk=1)
    ```
    
- Наконец, можно использовать и менеджер. Это полезно, например, если у вас есть специальный менеджер:
    
    ```Python
    get_object_or_404(Book.dahl_objects, title="Matilda")
    ```
    
- Также можно использовать связанные менеджеры:
    
    ```Python
    author = Author.objects.get(name="Roald Dahl")
    get_object_or_404(author.book_set, title="Matilda")
    ```
    

**Примечание**: Как и с методом `get()`, если найдено более одного объекта, будет сгенерировано исключение `MultipleObjectsReturned`.

### Lookups

**Lookups** в Django - это специальные методы или аргументы, которые используются для фильтрации QuerySet'ов, позволяя выбирать только определенные записи из базы данных, соответствующие определенным критериям.

**Синтаксис**:

```Python
# перед типом lookup используется двойное подчёркивание!
MyModel.objects.filter(field__lookuptype=value)
```

**Некоторые полезные lookups:**

- **exact:** Соответствует точному значению.
- **iexact:** Соответствует точному значению, игнорируя регистр.
- **contains:** Содержит заданное значение.
- **icontains:** Содержит заданное значение, игнорируя регистр.
- **in:** Соответствует одному из списка значений.
- **startswith:** Начинается с заданного значения.
- **istartswith:** Начинается с заданного значения, игнорируя регистр.
- **endswith:** Заканчивается заданным значением.
- **iendswith:** Заканчивается заданным значением, игнорируя регистр.
- **gt:** Больше, чем заданное значение.
- **gte:** Больше или равно заданному значению.
- **lt:** Меньше, чем заданное значение.
- **lte:** Меньше или равно заданному значению.
- **isnull:** Является ли значение null.
- **isblank:** Является ли значение пустой строкой.
- **date:** Соответствует дате.
- **time:** Соответствует времени.
- **year:** Соответствует году.
- **month:** Соответствует месяцу.
- **day:** Соответствует дню.
- **week_day:** Соответствует дню недели.
- **regex:** Соответствует регулярному выражению.
- **range:** Соответствует диапазону значений.

**Примеры**:

```Python
MyModel.objects.filter(name__exact="John")

MyModel.objects.filter(published_date__date=datetime.date(2023, 1, 1))

MyModel.objects.filter(age__range=(20, 30))

MyModel.objects.filter(tags__in=["python", "django"])
```

### class Meta

Класс `Meta` - это вложенный класс, который используется для определения метаданных модели. Он предоставляет способ настройки различных аспектов поведения модели, таких как название таблицы в базе данных, порядок сортировки объектов, уникальные поля и многое другое. Класс `Meta` не является обязательным для модели.

Некоторые из атрибутов:

1. **db_table:**
    - Определяет имя таблицы в базе данных, которая будет связана с моделью. По умолчанию Django автоматически формирует имя таблицы, используя имя приложения и имя модели, но это атрибут позволяет переопределить это поведение.
    - Пример: `db_table = 'my_table'`
2. **ordering:**
    - Определяет порядок сортировки объектов при выполнении запросов без явного указания порядка сортировки. Может быть строкой (для одного поля) или кортежем (для нескольких полей).
    - Пример: `ordering = ['field1', '-field2']` (по возрастанию для поля `field1`, а затем по убыванию для поля `field2`)
3. **unique_together:**
    - Определяет комбинацию полей, которые должны быть уникальными вместе. Принимает список кортежей полей.
    - Пример: `unique_together = [('field1', 'field2')]`
4. **indexes:**
    - Определяет индексы, которые должны быть созданы для данной модели в базе данных. Принимает список `Index` объектов.
    - Пример: `indexes = [Index(fields=['field1', 'field2'])]`
5. **constraints:**
    - Определяет ограничения, которые должны быть применены к данной модели в базе данных. Принимает список `Constraint` объектов.
    - Пример: `constraints = [models.UniqueConstraint(fields=['field1', 'field2'], name='unique_constraint_name')]`
6. **abstract:** 
    
    - Если `True`, модель будет абстрактной и не будет использоваться для создания таблицы базы данных.
    
    - Абстрактная модель
        - Не используется для создания таблицы базы данных.
        - Служит шаблоном для создания других моделей.
        - Может содержать поля и методы, которые будут унаследованы дочерними моделями.
7. **proxy:** 
    
    - Если `True`, модель будет прокси-моделью, которая не будет иметь собственной таблицы базы данных.
    
    - Прокси модель
        - Представляет собой альтернативный интерфейс к существующей модели.
        - Не имеет собственной таблицы базы данных.
        - Использует ту же таблицу, что и модель, от которой она наследуется.
        - Может изменить поведение модели на уровне Python.

### Update

1. **Изменение атрибута объекта и сохранение изменений:**
    - Один из способ обновить данные в БД это получить объект из базы данных, изменить его атрибуты и затем вызвать метод `save()` для сохранения изменений в базе данных.
    - Пример:
        
        ```Python
        # Получаем объект из базы данных
        my_object = MyModel.objects.get(id=1)
        # Изменяем атрибут
        my_object.attribute = new_value
        # Сохраняем изменения в базе данных
        my_object.save()
        ```
        
    - Если в save() передать список имен полей в ключевом аргументе update_fields, то будут обновлены только те поля, которые указаны в этом списке. Может дать небольшой выигрыш в производительности.
        
        ```Python
        product.name = "Name changed again"
        product.save(update_fields=["name"])
        ```
        
2. **Метод** `**update()**` **для** `**objects**`**:**
    - Метод `update()` позволяет обновить значения полей для всех объектов, удовлетворяющих определенным условиям, без необходимости извлекать их из базы данных.  
        Если вы просто обновляете запись и вам не нужно ничего делать с объектом модели, то наиболее эффективным подходом будет вызов  
        `update()`, а не загрузка объекта модели в память (как в предыдущем способе).
    - Пример:
        
        ```Python
        # Обновление значений для всех объектов, удовлетворяющих условиям фильтрации
        MyModel.objects.filter(condition).update(field1=new_value1, field2=new_value2)
        ```
        
    - Можно инкрементно увеличивать или уменьшать данные, используя update и F() expressions.
        
        ```Python
        MyModel.objects.filter(condition).update(number=F(number) + 1)
        ```
        
3. **Метод** `**bulk_update()**` **для обновления нескольких объектов:**
    - Метод `bulk_update()` позволяет обновить значения полей для нескольких объектов модели в одном запросе к базе данных. Удобно, когда нужно изменить значения полей на разные данные, в отличии от метода `update`, где для всех объектов будет использоваться одно и то же значение.
    - Пример:
        
        ```Python
        # Получаем список объектов, которые нужно обновить
        objects_to_update = MyModel.objects.filter(condition)
        # Изменяем значения полей
        for obj in objects_to_update:
            obj.field1 = new_value1
            obj.field2 = new_value2
        # Вызываем bulk_update() для обновления значений
        MyModel.objects.bulk_update(objects_to_update, ['field1', 'field2'])
        ```
        
4. **Метод** `**update_or_create()**` **для обновления или создания объекта:**
    - Метод `update_or_create()` позволяет обновить существующий объект или создать новый, если объект с заданными параметрами не найден.
    - Пример:
        
        ```Python
        # Обновляем или создаем объект
        obj, created = Person.objects.update_or_create(
            first_name="John",
            last_name="Lennon",
            defaults={"first_name": "Bob"},
        )
        # vs:
        defaults = {"first_name": "Bob"}
        try:
            obj = Person.objects.get(first_name="John", last_name="Lennon")
            for key, value in defaults.items():
                setattr(obj, key, value)
            obj.save()
        except Person.DoesNotExist:
            new_values = {"first_name": "John", "last_name": "Lennon"}
            new_values.update(defaults)
            obj = Person(**new_values)
            obj.save()
        ```
        

### Delete

1. **Метод** `**delete()**` **на объекте модели:**
    - В Django можно удалить отдельные объекты модели, вызвав метод `delete()` на объекте модели.
    - Пример:
        
        ```Python
        my_object = MyModel.objects.get(id=1)
        my_object.delete()
        ```
        
2. **Метод** `**delete()**` **на QuerySet:**
    - Метод `delete()` можно вызвать на QuerySet, чтобы удалить набор объектов, удовлетворяющих определенным условиям.
    - Пример:
        
        ```Python
        MyModel.objects.filter(condition).delete()
        ```
        
3. **Использование** `**all()**` **и** `**delete()**` **вместе:**
    
    - Обратите внимание, что `delete()` - это единственный метод QuerySet, который не добавлен напрямую для самого менеджера `object`. Это защитный механизм, чтобы вы случайно не запросили `Entry.objects.delete()` и не удалили все записи. Если вы хотите удалить все объекты, то вам придется явно запросить полный набор записей.
    - Пример:
        
        ```Python
        MyModel.objects.all().delete()
        ```

<div class="page-break" style="page-break-before: always;"></div>
