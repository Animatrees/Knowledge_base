Наследование шаблонов

Тег extends

Тег block

Тег include

Контекстные процессоры

### Наследование шаблонов

Наследование это механизм, который позволяет создавать иерархию шаблонов для повторного использования кода и облегчения поддержки веб-страниц.  
Оно основано на концепции создания основного (родительского) шаблона, который определяет общий макет страницы, и дочерних шаблонов, которые наследуют этот макет и могут дополнять или переопределять его содержимое по мере необходимости.  

**Родительский шаблон (base.html)**:  
Родительский шаблон определяет основной макет страницы, который обычно включает общие элементы, такие как header, меню, footer и т.д.  
Этот шаблон может содержать пустые блоки, предназначенные для заполнения содержимым из дочерних шаблонов.  
Базовый шаблон обычно хранится в директории  
`**templates**` внутри приложения или в общей директории `**templates**` внутри корневой директории проекта. Рекомендуется хранить базовый шаблон в директории `**templates**` внутри самого проекта.  
Помещение базового шаблона в директорию  
`**templates**` внутри проекта делает его доступным для всех приложений в проекте. Это обеспечивает централизованное хранение и управление шаблоном, что упрощает его обновление и модификацию.

> [!important]  
> Для того, чтобы подключить базовый шаблон корректно - создаём директорию templates в главной директории проекта, на том же уровне, где находятся директории приложений и директория с файлами для настройки проекта. Создаём внутри директории templates файл base.html. myproject/├── myproject/│ ├── init.py│ ├── settings.py│ ├── …├── myapp/│ ├── migrations/│ ├── models.py│ └── views.py│ ├── …└── templates/│ ├── base.htmlВ файле settings.py прописываем путь до директории в переменную DIRS - BASE_DIR / 'templates'. После этого базовый шаблон будет доступен в шаблонах приложений по пути - ‘base.html’  

**Дочерние шаблоны**:  
Дочерние шаблоны наследуют родительский шаблон и могут переопределять или дополнять его содержимое по мере необходимости.  
Они могут добавлять уникальное содержимое в блоки, определенные в родительском шаблоне, а также расширять функциональность шаблона посредством включения дополнительных блоков.  
Для наследования в дочерних шаблонах используется тег  
`{% extends %}`, а также теги `{% block %}` для определения и переопределения блоков содержимого.

**Блоки**:  
Это специальные области в родительском шаблоне, которые могут быть переопределены в дочерних шаблонах.  
Они представляют собой контейнеры для содержимого, который будет вставлен в родительский шаблон из дочерних шаблонов. Используя такое же название блока в дочернем шаблоне, как в родительском можно полностью перезаписать контент блока или дополнить его, используя тег  
`{% block.super %}`.

### Тег extends

Тег `**{% extends %}**` используется для указания того, какой шаблон является родительским для текущего шаблона. При использовании этого тега текущий шаблон будет наследовать содержимое (блоки) из указанного родительского шаблона.

> [!important]  
> Тег {% extends %} должен быть первым тегом в шаблоне, и его можно использовать только один раз в шаблоне. Он указывает Django, какой шаблон должен быть базовым для текущего шаблона, и определяет начало наследования содержимого между шаблонами.  

**Синтаксис:**

```Python
{% extends "parent_template.html" %}
```

Здесь `**"parent_template.html"**` - это имя файла родительского шаблона, который вы хотите наследовать.

**Пример использования тега** `**{% extends %}**`:

```HTML
{% extends "base.html" %}

{% block content %}
    <h1>Привет, мир!</h1>
    <p>Это мой первый сайт на Django.</p>
{% endblock %}
```

В этом примере текущий шаблон наследует содержимое из родительского шаблона `**"base.html"**`. Весь контент, который находится в блоке `**{% block content %}{% endblock %}**`, будет вставлен в блок с тем же именем в родительском шаблоне.

### Тег block

Тег `**{% block %}**` используется для определения блоков содержимого в родительском шаблоне, которые могут быть переопределены или расширены в дочерних шаблонах. Он позволяет создавать области в родительском шаблоне, в которые можно вставлять уникальное содержимое из дочерних шаблонов.

**Синтаксис**:

```Python
{% block block_name %}
    <!-- Содержимое блока -->
{% endblock %}
```

Здесь `**block_name**` - это имя блока, которое вы определяете в родительском шаблоне.

- Имя блока в теге `**{% block %}**` может быть любым. Оно должно быть уникальным в пределах родительского шаблона и может содержать только буквы, цифры и знаки подчеркивания. Имя блока используется для определения области, в которую можно вставить содержимое в дочерних шаблонах.
- В закрывающем теге блока также можно указать имя блока, чтобы было наглядное отображение того, какой именно блок закрывается. Это полезно, если в шаблоне много блоков и вы хотите явно указать, к какому блоку относится закрывающий тег.

**Пример использования тега** `**{% block %}**` **в родительском шаблоне:**

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Мой сайт{% endblock %}</title>
</head>
<body>
    <header>
        {% block header %}Это header{% endblock %}
    </header>
    <nav>
        {% block nav %}Это навигационное меню{% endblock %}
    </nav>
    <main>
        {% block content %}Какой-то контент{% endblock %}
    </main>
    <footer>
        {% block footer %}Это footer{% endblock %}
    </footer>
</body>
</html>
```

В дочернем шаблоне блоки могут быть переопределены или расширены по мере необходимости.  
Например:  

```HTML
{% extends "base.html" %}

{% block title %}Моя страница{% endblock %}

{% block content %}
    <h1>Привет, мир!</h1>
    <p>Это мой первый сайт на Django.</p>
{% endblock %}
```

Здесь блоки `**title**` и `**content**` переопределены в дочернем шаблоне, а остальные блоки остаются такими же, как в родительском шаблоне.

**Переменная block.super**

В дочернем шаблоне также можно использовать переменную `**block.super**`, чтобы получить содержимое блока из родительского шаблона. Это позволяет расширить содержимое родительского блока, добавив к нему дополнительный контент, а не заменяя его полностью.

Пример использования переменной `**block.super**`:

```HTML
{% extends "base.html" %}

{% block title %}Моя страница{% endblock %}

{% block content %}
    {{ block.super }}
    <p>Дополнительный контент для страницы</p>
{% endblock %}
```

В этом примере содержимое блока `**content**` из родительского шаблона будет выведено с помощью `**{{ block.super }}**`, а затем добавлен дополнительный контент. Таким образом, контент из родительского блока будет не заменен, а дополнен.

### Тег include

Тег `**{% include %}**` используется для включения содержимого одного шаблона в другой шаблон. Это удобно для повторного использования общих элементов интерфейса, таких как заголовки, навигационные меню, футеры и т.д., в разных частях проекта.

**Синтаксис**:

```Python
{% include "template_name.html" %}
```

Здесь `**"template_name.html"**` - это имя файла шаблона, который вы хотите включить в текущий шаблон.

1. **Дополнительные настройки**:
    - `**with**`: можно использовать опциональное ключевое слово `**with**`, чтобы передать дополнительные переменные включаемому шаблону. Например:
        
        ```Python
        {% include "template_name.html" with variable_name=value %}
        ```
        
        Здесь `**variable_name**` - это имя переменной, а `**value**` - значение, которое будет передано включаемому шаблону.
        
    - `**only**`: для того, чтобы включить только содержимое указанного шаблона, без наследования от текущего контекста, можно использовать опцию `**only**`. Например:
        
        ```Python
        {% include "template_name.html" only %}
        ```
        
        Это полезно, когда вы хотите избежать конфликтов имен переменных между включаемым шаблоном и текущим контекстом.
        

### Контекстные процессоры

`**context_processors**` - это механизм, который позволяет добавлять дополнительные данные в контекст каждого шаблона перед его рендерингом. Эти данные могут быть общими для всех шаблонов проекта и могут использоваться для предоставления информации, которая часто используется в шаблонах, такой как данные пользователя, настройки сайта, меню навигации и т.д.

Контекстные процессоры представляют собой функции Python, которые принимают объект запроса (`**request**`) и возвращают словарь с данными, которые вы хотите добавить в контекст шаблона. Эти функции вызываются Django для каждого запроса перед тем, как он обрабатывается шаблонизатором.

**Процедура создания кастомного контекстного процессора:**

1. Создаём модуль Python в приложении (например, `**context_processors.py**`), где будет содержаться контекстный процессор.
2. В этом модуле определяем функцию, которая будет предоставлять данные для контекста. Эта функция должна принимать объект запроса и возвращать **словарь** с данными.

```Python
# myapp/context_processors.py

def get_custom_context(request):
    menu_items = [{'title': "Главная", 'url_name': 'home'},
                  {'title': "О сайте", 'url_name': 'about'},
                  {'title': "Добавить статью", 'url_name': 'add_page'},
                  {'title': "Обратная связь", 'url_name': 'contact'},
                  {'title': "Войти", 'url_name': 'login'}
                  ]

    return {'menu': menu_items}
```

1. Регистрируем эту функцию в настройках Django в списке `**context_processors**` внутри параметра `**OPTIONS**` для шаблонов.

```Python
# settings.py

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                # Другие процессоры контекста
                'myapp.context_processors.get_custom_context',
            ],
        },
    },
]
```

Теперь данные, возвращаемые контекстным процессором, будут доступны в каждом шаблоне проекта, и можно будет обращаться к ним, используя ключи, указанные в возвращаемом словаре (например, `**{% for m in menu %}**` в шаблоне).

<div class="page-break" style="page-break-before: always;"></div>
