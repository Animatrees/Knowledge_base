Загрузка файла на чистом HTML

Сохранение файла на сервере

Классы forms.FileField и forms.ImageField

Способы генерации случайных имён

### Загрузка файла на чистом HTML

Атрибут **`enctype="multipart/form-data"`** в HTML-формах играет ключевую роль при отправке файлов с помощью веб-страницы на сервер. Он указывает браузеру на то, что форма содержит файлы для отправки, и определяет способ кодирования и отправки данных.

Важность этого атрибута связана с тем, что по умолчанию браузеры используют кодирование данных формы в виде `application/x-www-form-urlencoded`, когда вы отправляете данные с помощью метода POST. Однако этот тип кодирования не подходит для отправки файлов, потому что он не может обрабатывать бинарные данные, такие как изображения, видео, аудио и другие файлы.

При использовании `enctype="multipart/form-data"`, данные формы кодируются специальным образом, который позволяет передавать бинарные файлы вместе с текстовыми данными. Это делается путем разделения данных формы на несколько частей, каждая из которых содержит часть данных, включая файлы, и каждая часть отправляется на сервер по отдельности. Этот метод кодирования позволяет безопасно отправлять файлы любого типа и размера.

Таким образом, без атрибута `enctype="multipart/form-data"` браузер не сможет правильно обрабатывать и отправлять файлы, и сервер не сможет корректно принять их. Поэтому важно всегда включать этот атрибут в HTML-формы, когда вы планируете отправлять файлы на сервер.

**Пример HTML для выгрузки файла на сервер:**

```HTML
<form action="" method="post" enctype="multipart/form-data">
    {% csrf_token %}
    <p ><input type="file" name="file_upload"></p>
    <p ><button type="submit">Отправить</button></p>
</form>
```

**Пошагово**:

1. **Создание HTML-формы**:
    - Создайте HTML-форму с атрибутом `enctype="multipart/form-data"`, который позволяет отправлять файлы.
    - Включите поле `<input type="file">` для выбора файла.
    - Убедитесь, что у формы есть атрибут `method="post"` и добавьте кнопку отправки.
    - Не забудьте добавить `{% csrf_token %}`
2. **Обработка запроса на сервере**:
    - Когда пользователь отправляет форму, браузер создает HTTP POST запрос на сервер.
    - Django получает этот запрос и передает его в соответствующую view-функцию.
3. **Извлечение файла из запроса**:
    - В вашей view-функции вы должны извлечь файл из объекта `request.FILES`. Django автоматически помещает файлы, отправленные через форму с атрибутом `enctype="multipart/form-data"`, в `request.FILES`.
4. **Обработка файла**:
    - Выполните необходимые действия с загруженным файлом, такие как сохранение на сервере, обработка его содержимого или связывание с объектом модели Django.
5. **Отправка ответа клиенту**:
    - После обработки файла и выполнения всех необходимых действий отправьте ответ клиенту. Это может быть перенаправление на другую страницу, отображение сообщения об успехе или что-то еще.

### Сохранение файла на сервере

Методы `chunks()` и `read()` - предоставляют способы загрузки файлов на сервер в Django.

1. `**UploadedFile.chunks()**`:
    
    Метод `chunks()` разбивает файл на блоки определенного размера и возвращает итератор, который позволяет читать файл блок за блоком.
    
    ```Python
    def handle_uploaded_file(file):
        with open(f'uploads/{f.name}', 'wb+') as destination:
            for chunk in file.chunks():
                destination.write(chunk)
    ```
    
    - **Плюсы**:
        - Эффективно обрабатывает большие файлы, так как не загружает весь файл в память одновременно.
        - Полезен для обработки потоков данных.
    - **Минусы**:
        - Может потребовать дополнительной обработки для объединения блоков данных обратно в файл, если это необходимо.
        - Может потребовать больше кода для обработки в сравнении с методом `read()`.
2. `**read()**`:
    
    Метод `read()` читает и возвращает содержимое файла целиком.
    
    ```Python
    def handle_uploaded_file(file):
        with open(f'uploads/{f.name}', 'wb+') as destination:
            destination.write(file.read())
    ```
    
    - **Плюсы**:
        - Прост в использовании и понимании.
        - Подходит для небольших файлов или когда требуется загрузить весь файл в память одновременно.
    - **Минусы**:
        - Может быть неэффективен для больших файлов, так как требует загрузки всего файла в память.
        - Может привести к проблемам с производительностью и использованием памяти при обработке больших файлов.

Используем один из методов в функции-представлении (преимущественно первый). Не забудьте предварительно создать директорию - **uploads**, куда будут загружаться полученные файлы!

```Python
def about(request):
    if request.method == "POST":
        handle_uploaded_file(request.FILES['file_upload'])
 
    return render(request, 'women/about.html', {'title': 'О сайте', 'menu': menu})
```

> [!important]  
> Обратите внимание, что request.FILES будет содержать данные только в том случае, если метод запроса был POST, по крайней мере одно поле файла было фактически отправлено, а <form> отправивший запрос имеет атрибут enctype="multipart/form-data. В противном случае request.FILES будет пустым.  

### Классы forms.FileField и forms.ImageField

Классы `**FileField**` и `**ImageField**` в Django используются для работы с загрузкой файлов на сервер. Они представляют соответственно обычные файлы и изображения.

1. `**FileField**`:
    
    - Позволяет загружать любые типы файлов на сервер.
    - По умолчанию не выполняет никаких проверок на тип или содержимое файла.
    - Имеет необязательные аргументы для проверки: `max_length` и `allow_empty_file`. Если они указаны, то гарантируют, что имя файла будет не более заданной длины, и что проверка пройдет успешно, даже если содержимое файла пустое.
    
    ```Python
    from django import forms
    
    class UploadFileForm(forms.Form):
        file = forms.FileField()
    ```
    
2. `**ImageField**`:
    
    - Предназначен специально для загрузки изображений на сервер.
    - По умолчанию выполняет проверки на тип файла и проверяет, что загруженный файл действительно является изображением.
    - Использование ImageField **требует**, чтобы Pillow был установлен с поддержкой используемых вами форматов изображений. Если при загрузке изображения вы столкнулись с ошибкой поврежденного изображения, это обычно означает, что Pillow не понимает его формат. Чтобы исправить это, установите соответствующую библиотеку и переустановите Pillow.
    
    ```Python
    from django import forms
    
    class UploadImageForm(forms.Form):
        image = forms.ImageField()
    ```
    

Процедура сохранения файла на сервер аналогична предыдущему описанию. Мы используем уже описанную ранее функцию `handle_uploaded_file()` для сохранения файла. В функции представлении:

- создаём файл формы с данными, полученными в словари POST и FILES
- проверяем форму на валидность
- используем функцию `handle_uploaded_file()`

```Python
def about(request):
    if request.method == "POST":
        form = UploadFileForm(request.POST, request.FILES)
        if form.is_valid():
            handle_uploaded_file(form.cleaned_data['file'])
    else:
        form = UploadFileForm()
 
    return render(request, 'women/about.html', {'title': 'О сайте', 'menu': menu, 'form': form})
```

### Способы генерации случайных имён

Есть несколько способов обеспечить уникальность для имени, чтобы исключить вероятность возникновения одинаковых имён.

1. **Использование временной метки и случайной строки**:  
    Вы можете использовать текущую временную метку вместе с случайной строкой в качестве уникального имени файла. Это обеспечит уникальность идентификатора файла, поскольку вероятность одинаковых временных меток и случайных строк крайне мала.  
    
    **Пошагово:**
    
    - Для получение текущей временной метки вы можете использовать стандартную библиотеку Python `datetime`.
    - Чтобы сгенерировать случайную строку можно использовать модуль `random` или стандартную библиотеку Python `secrets`.
    
    Пример комбинация временной метки и случайной строки в качестве имени файла:
    
    ```Python
    import datetime
    import random
    import string
    
    def generate_unique_filename():
        timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
        random_string = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
        unique_filename = f"{timestamp}_{random_string}"
        return unique_filename
    ```
    
2. **Хэширование содержимого файла**:  
    Другой способ - это использование хэш-функции для вычисления хэша содержимого файла. Затем вы можете использовать этот хэш в качестве уникального имени файла. Это гарантирует, что два файла  
    **с разным содержимым** будут иметь разные имена.
    
    **Пошагово:**
    
    - Для вычисления хэша содержимого файла можно использовать любую хэш-функцию, такую как SHA-256.
    
    Пример использования строки хэша в качестве имени файла.
    
    ```Python
    import hashlib
    
    def generate_unique_filename(file_content):
        file_hash = hashlib.sha256(file_content).hexdigest()
        return file_hash
    ```
    
3. **Использование временной метки и уникального идентификатора сессии**:  
    Вы также можете использовать текущую временную метку вместе с уникальным идентификатором сессии пользователя в качестве уникального имени файла. Это поможет обеспечить уникальность имени файла в рамках каждой сессии пользователя.  
    
    Пошагово:
    
    - Получите текущую временную метку, используя datetime.
    - Получите уникальный идентификатор сессии пользователя. В Django вы можете получить его из объекта запроса.
    
    Пример комбинации временной метки и идентификатора сессии в качестве имени файла:
    
    ```Python
    import datetime
    
    def generate_unique_filename(request):
        timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
        session_id = request.session.session_key
        unique_filename = f"{timestamp}_{session_id}"
        return unique_filename
    ```

<div class="page-break" style="page-break-before: always;"></div>
