Полезные ресурсы

Стратегии кэширования в контексте Django

Алгоритмы вытеснения данных

Стратегии инвалидации данных

Метрики кэширования

### Полезные ресурсы

Информации на уроке мне как обычно не хватило (ведь тема кэширования гораздо обширнее, чем капчу прикрутить!), и потому пошла на просторы интернета за добавкой.

**Чего нашла:**

1. Довольно подробно про теоретическую базу всего этого дела:
    
    > [!info] System Design - теория кэширования | Как кэшировать данные  
    > Курсы по программированию: https://clck.  
    > [https://www.youtube.com/watch?v=iLMlYgQoTIE](https://www.youtube.com/watch?v=iLMlYgQoTIE)  
    
2. Почти тоже самое, но в текстовом виде:
    
    > [!info] [По полочкам] Кэширование  
    > Всем привет!  
    > [https://habr.com/ru/articles/734660/](https://habr.com/ru/articles/734660/)  
    
3. Более развёрнуто про сам Redis:
    
    > [!info] Redis за 20 минут  
    > В этом видео мы поговорим о Redis.  
    > [https://www.youtube.com/watch?v=QpBaA6B1U90](https://www.youtube.com/watch?v=QpBaA6B1U90)  
    
4. Как реализовать ручную инвалидацию и обновление кэша:
    
    > [!info] Оптимизация Django. 8 - Redis и ручной кеш  
    >  
    > [https://www.youtube.com/watch?v=wv3CIQH9u-E](https://www.youtube.com/watch?v=wv3CIQH9u-E)  
    
5. И бонусное видео с выходом за рамки Redis-а)
    
    > [!info] Андрей Фёдоров, «Кэш на уровне приложения в распределенной системе / прожить без Redis и Memcached»  
    > Описание доклада:  
    > [https://www.youtube.com/watch?v=BvgEOOTYQRI](https://www.youtube.com/watch?v=BvgEOOTYQRI)  
    

  

Нижеследующую информацию лучше читать после просмотра 1 видео из списка или прочтения 2 статьи.

### Стратегии кэширования в контексте Django

Если рассматривать Django-приложение в целом, то очевидно, что оно не использует кэш как обязательную промежуточную прослойку между приложением и источником данных (базой данных). **Приложение может взаимодействовать с базой данных напрямую, минуя кэш.**

В этом контексте стратегия кэширования в Django больше соответствует **Cache-Aside** (Кэширование на стороне):

![[Untitled 20.png|Untitled 20.png]]

1. Приложение имеет два отдельных хранилища данных - базу данных и кэш (Redis).
2. Оно самостоятельно координирует, когда обращаться к кэшу, а когда к базе данных.
3. Для некэшированных запросов приложение взаимодействует напрямую с базой данных.
4. Для кэшированных уровней (per-site, per-view) оно сначала проверяет кэш, а при отсутствии данных обращается к базе данных.
5. Полученные из базы данные записываются в кэш для последующего использования.

Таким образом, на уровне всего приложения Django использует стратегию Cache-Aside, где кэш выступает как дополнительное временное хранилище рядом с основным (базой данных). А сквозное кэширование (Cache-Through) применяется только для определенных уровней кэширования внутри самого приложения.

Например, для per-site кэширования используется стратегия **Cache-Through** (Сквозное кэширование).

![[Untitled 1 10.png|Untitled 1 10.png]]

**Ключевые моменты, указывающие на это:**

1. Два промежуточных обработчика (middleware) `UpdateCacheMiddleware` и `FetchFromCacheMiddleware` добавляются в конвейер обработки запросов Django. Они выступают связующим звеном между приложением и кэшем/основным хранилищем.
2. Все входящие запросы проходят через этот конвейер обработчиков. `FetchFromCacheMiddleware` пытается получить ответ из кэша, если его там нет - запрос проходит дальше к приложению.
3. Ответы из приложения затем обрабатываются `UpdateCacheMiddleware`, который кэширует их на заданное время (`CACHE_MIDDLEWARE_SECONDS`).
4. Для приложения кэш и основное хранилище представлены как единый компонент благодаря этим промежуточным обработчикам.

Per-view кэширование с помощью декоратора `cache_page` также реализует стратегию **Cache-Through**, где кэш выступает обязательным промежуточным слоем для обращений к кэшированным представлениям.

1. Декоратор `cache_page` возвращает объект класса CacheMiddleware, который наследуется от UpdateCacheMiddleware и FetchFromCacheMiddleware.
2. Как мы выяснили ранее, эти классы реализуют стратегию Cache-Through для per-site кэширования.
3. Таким образом, при использовании декоратора `cache_page` обращения к кэшированным представлениям проходят через экземпляр CacheMiddleware, который выступает промежуточным слоем между приложением и кэшем.
4. CacheMiddleware сначала пытается получить данные из кэша (через FetchFromCacheMiddleware), и если их нет, пропускает запрос к представлению.
5. Результат выполнения представления затем кэшируется CacheMiddleware (через UpdateCacheMiddleware).

В случае же кэширования фрагментов шаблонов Django предоставляет удобный инструмент в виде тега {% cache %} для явного указания областей кэширования, соответствующий стратегии **Cache-Aside** на уровне шаблонов.

1. Приложение (в данном случае шаблон) самостоятельно решает, какие фрагменты кэшировать, оборачивая их тегом {% cache %}.
2. Перед отображением фрагмента шаблон проверяет наличие этого фрагмента в кэше.
3. Если фрагмент есть в кэше, он отображается оттуда. Если нет - фрагмент вычисляется и кэшируется.
4. Таким образом, шаблон рассматривает кэш и основной источник данных (вычисление фрагмента) как два отдельных компонента и координирует обращения между ними.

### **Алгоритмы вытеснения данных**

Django сам по себе не имплементирует какие-либо алгоритмы вытеснения данных из кэша. Вместо этого, он полагается на встроенные механизмы вытеснения, предоставляемые используемым бэкэндом кэширования.

**В Redis доступны следующие алгоритмы вытеснения данных:**

- **noeviction**
    - При достижении лимита памяти новые данные не сохраняются, и Redis возвращает ошибки для команд, которые могут увеличить использование памяти.
    - Применяется, когда важно сохранить все существующие данные, и новые данные могут быть отклонены. Используется в сценариях, где потеря данных недопустима.
- **allkeys-lru** (Least Recently Used)
    - Удаляются ключи, к которым дольше всего не было обращений.
    - Применяется, когда небольшое подмножество ключей будет использоваться значительно чаще остальных. Это хороший выбор, если точно не известно, какую политику использовать.
- **allkeys-lfu** (Least Frequently Used)
    - Удаляются ключи, обращений к которым было меньше всего.
    - Применяется, когда некоторые ключи используются значительно чаще остальных, и есть необходимость сохранить часто используемые ключи.
- **volatile-lru**
    - Это разновидность LRU, которая применяется только к данным с установленным TTL (Time-to-Live, время жизни). Элементы без TTL не вытесняются.
    - Применяется, когда нужно освобождать место только среди ключей, у которых задано время жизни, удаляя при этом те, которые давно не использовались. Это полезно, если нужно сохранять постоянные данные, но можно удалить временные данные, которые не использовались длительное время.
- **volatile-lfu**
    - Это разновидность LFU, которая применяется только к данным с установленным TTL. Элементы без TTL не вытесняются.
    - Полезно для удаления редко используемых ключей среди тех, у которых задано время жизни, сохраняя при этом часто используемые ключи. Это позволяет сохранять важные временные данные, удаляя менее важные, которые используются реже.
- **allkeys-random**
    - Удаляются случайные ключи.
    - Применяется, когда распределение доступа к ключам равномерное или цикличное, и все ключи сканируются непрерывно.
- **volatile-random**
    - Удаляются случайные ключи с установленным временем жизни (TTL).
    - Применяется, когда нужно освободить место, удаляя любые ключи с установленным временем жизни случайным образом. Это полезно в ситуациях, когда нет необходимости следить за тем, какие ключи удаляются, и достаточно просто освободить место среди временных данных.
- **volatile-ttl**
    - Удаляются ключи с наименьшим оставшимся временем жизни (TTL).
    - Применяется, когда нужно освободить место, удаляя в первую очередь те ключи, которые скоро истекут. Это полезно, если важно сохранять данные, срок действия которых еще долго не истечет, и удалить те, которые уже почти истекли, освобождая место для новых данных.

> [!important]  
> По умолчанию в Redis используется политика вытеснения noeviction.  

Политику вытеснения в Redis можно изменить с помощью директивы `maxmemory-policy` в конфигурационном файле `redis.conf` или с помощью команды `CONFIG SET` во время выполнения.

**Изменение через конфигурационный файл**

1. Откройте файл конфигурации `redis.conf`.
2. Найдите строку, содержащую директиву `maxmemory-policy`.
3. Установите нужную политику. Например, чтобы установить политику `allkeys-lru`, измените строку следующим образом:
    
    ```Bash
    maxmemory-policy allkeys-lru
    ```
    
4. Перезапустите Redis, чтобы изменения вступили в силу.

**Изменение во время выполнения**

1. Подключитесь к Redis с помощью командной строки:
    
    ```Bash
    redis-cli
    ```
    
2. Выполните команду `CONFIG SET`, указав нужную политику. Например, чтобы установить политику `allkeys-lru`, выполните:
    
    ```Bash
    CONFIG SET maxmemory-policy allkeys-lru
    ```
    

**Директива конфигурации Maxmemory**

Директива конфигурации `maxmemory` задает, какое количество памяти Redis может использовать для набора данных. Эту директиву можно установить с помощью файла конфигурации `redis.conf` или командой `CONFIG SET` во время выполнения.

Например, чтобы установить предел памяти в 100 мегабайт, можно использовать следующую директиву в файле `redis.conf`:

```Shell
maxmemory 100mb
```

Установка значения `maxmemory` в ноль означает отсутствие ограничений по памяти. Это поведение по умолчанию для 64-битных систем, в то время как для 32-битных систем используется неявное ограничение памяти в 3 ГБ. По умолчанию установлена в 0.

Также есть несколько дополнительных настроек, как maxmemory-samples, lfu-log-factor или lfu-decay-time про которые можно прочитать подробнее в [документации](https://redis.io/docs/latest/develop/reference/eviction/))

### **Стратегии инвалидации данных**

Django не имеет универсальной стратегии инвалидации кэша. Вместо этого, он предоставляет несколько механизмов для управления инвалидацией кэша в зависимости от ситуации:

- **Явная инвалидация**
    - Механизм позволяет вручную удалять элементы из кэша с использованием методов `cache.delete()` или `cache.clear()`.
    - Подходит для случаев, когда необходимо точно контролировать, какие элементы и когда должны быть удалены из кэша.
- **Инвалидация на основе срока жизни (TTL - Time To Live)**
    - При кэшировании элемента через низкоуровневый API (`cache.set()`) или при использовании декоратора `cache_page` можно указать срок жизни (TTL) для кэшируемого элемента.
    - TTL определяет, через какое время элемент должен быть автоматически удален из кэша.
    - Полезно для данных, которые имеют предсказуемый срок действия и могут быть автоматически удалены через определенное время.
- **Сигналы инвалидации**
    - Django предоставляет систему сигналов, которые могут быть использованы для инвалидации кэша при определенных событиях.
        - Наиболее распространенный случай - инвалидация при изменении данных модели (создание, обновление или удаление).
        - Для этого необходимо подключить обработчики сигналов к соответствующим сигналам моделей (`post_save`, `post_delete` и т.д.).
        - В обработчиках сигналов можно выполнять явную инвалидацию связанных с моделью элементов в кэше.
        - Это позволяет поддерживать согласованность между данными в кэше и основным хранилищем данных.

### Метрики кэширования

Django сам по себе не предоставляет встроенных метрик для оценки работы кэша. Однако, Redis предлагает различные метрики и инструменты мониторинга, которые можно использовать для анализа производительности и эффективности кэширования.

- **Команды INFO и MONITOR в Redis**
    - **INFO**: Команда `INFO` предоставляет подробную статистику о состоянии Redis, включая использование памяти, количество ключей, частоту попаданий и промахов в кэш, а также другие важные метрики.
        
        ```Plain
        redis-cli INFO
        ```
        
    - **MONITOR**: Команда `MONITOR` позволяет в реальном времени отслеживать все команды, выполняемые на сервере Redis, что может быть полезно для детального анализа производительности и выявления узких мест.
        
        ```Plain
        redis-cli MONITOR
        ```
        
- **Сторонние инструменты мониторинга**
    - **Redis Commander**: Удобный инструмент для визуализации данных и мониторинга метрик Redis. Он предоставляет графический интерфейс для просмотра статистики, управления ключами и выполнения команд Redis.
    - **RedisInsight**: Еще один мощный инструмент для анализа и мониторинга Redis, который предлагает визуализацию метрик, профилирование запросов и другие полезные функции.
- **Интеграция с системами мониторинга (продвинутый уровень)**
    
    - **Prometheus и Grafana**: Можно настроить экспортеры метрик для Redis и интегрировать их с Prometheus для сбора данных. Grafana, в свою очередь, позволит создавать красивые и информативные дашборды для визуализации метрик производительности.
    - **New Relic и другие APM-инструменты**: Инструменты для мониторинга производительности приложений (APM) могут быть использованы для отслеживания метрик кэширования и анализа их влияния на производительность приложения.

<div class="page-break" style="page-break-before: always;"></div>
