Поиск

Фильтрация

SimpleListFilter

### **Поиск**

- Django Admin по умолчанию предоставляет панель поиска - `search_fields`, которая позволяет искать по всем полям модели.
- Django разбивает поисковый запрос на слова и возвращает все объекты, содержащие каждое из слов, без учета регистра - `icontains`, где каждое слово должно быть хотя бы в одном из полей `search_fields`. ==*На версии Django - 4.2 в связке с SQLite - поиск регистрозависимый.==
- Если вы не хотите использовать `icontains` в качестве настройки по умолчанию, вы можете использовать любой lookup, добавив его к полю. Например, можно использовать `exact`, установив search_fields в ['first_name__exact'].
- **Поиск по связанным моделям:** Вы также можете искать по связанным полям, используя `__` : `search_fields = ["user__email"]`
- **Кастомная обработка запросов:** Переопределите метод `ModelAdmin.get_search_results()` для более сложной логики поиска.

**Пример поиска по полю модели и связанному полю:**

```Python
from django.contrib import admin
from .models import Post

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    search_fields = ('title', 'cat__name')
```

> [!important]  
> Поиск, использующий несколько полей, применяется теперь при помощи одного вызова filter(), а не нескольких последовательных. Это влияет на поиск по связи много-ко-многим (ManyToMany). Раньше объект возвращался, если он соответствовал любому из введенных полей, а теперь ему необходимо соответствовать всем полям сразу.При search_fields = ['child__name', 'child__age'] и поиске "Jamal 17", объект родителя будет возвращен, только если у него связан ребенок 17 лет по имени Jamal. В ранних версиях Django родитель был бы включен в выдачу, даже если у него есть ребенок по имени Jamal другого возраста.  

### **Фильтрация**

- Для добавления фильтрации вы можете использовать атрибут `list_filter`. Этот атрибут принимает коллекцию имен полей, по которым будет доступна фильтрация.
- **Фильтрация по связанным полям:** Вы также можете фильтровать данные по связанным полям.

**Пример:**

```Python
from django.contrib import admin
from .models import Post

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_filter = ('title', 'content', 'cat__title')
```

### SimpleListFilter

Один из вариантов создания кастомных фильтров это наследование от `SimpleListFilter`. Он используется, когда для фильтра, который мы хотим создать, не предусмотрено какое-то конкретное поле в модели.

**Процесс создания фильтра:**

- Создаём класс, который наследуется от `admin.SimpleListFilter`.
- Определяем метод `title()`:
    
    Этот метод возвращает отображаемое название фильтра.
    
- Определяем метод `parameter_name()`:
    
    Этот метод возвращает имя параметра фильтра, которое будет передаваться в URL-адресе.
    
- Определяем метод `lookups()`:
    
    Этот метод возвращает список кортежей с вариантами фильтрации. Каждый кортеж содержит два значения: (значение, отображаемое имя).
    
- Определяем метод `queryset()`:
    
    Этот метод фильтрует queryset модели на основе выбранных значений фильтра.
    

**Пример:**

```Python
# admin.py

class MarriedFilter(admin.SimpleListFilter):
    title = 'Семейное положение'
    parameter_name = 'status'
    
    def lookups(self, request, model_admin):
        return [
            ('married', 'Замужем'),
            ('single', 'Не замужем'),
        ]
 
    def queryset(self, request, queryset):
        return queryset
```

Добавляем кастомный фильтр, используя название класса в коллекцию `list_filter`.

```Python
@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    ...
    list_filter = (MarriedFilter, 'title', 'cat__name')
```

<div class="page-break" style="page-break-before: always;"></div>
