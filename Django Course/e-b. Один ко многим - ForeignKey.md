Описание связи и основные параметры

Прямые и обратные отношения

Дополнительные методы родителя.

### Описание связи и основные параметры

Тип связи "Один ко многим" (или ForeignKey в Django) представляет отношение, при котором каждый объект одной модели связан с одним объектом другой модели, но объекты второй модели могут быть связаны с несколькими объектами первой модели.

При определении связи ForeignKey Django добавляет внутренний ключ (foreign key) к родительской модели в дочернюю модель. Затем Django автоматически создает поле в дочерней таблице базы данных, добавляя к имени поля "_id". Это поле будет содержать идентификатор родительской записи. А также формирует связи между таблицами на уровне базы данных, обеспечивая согласованность данных в соответствии с определением моделей.

**Синтаксис**

```Python
class ForeignKey(to, on_delete, **options)
```

Где:

- **to** - ссылка на модель, с которой будет устанавливаться связь. Возможны как строка с названием модели, так и указание модели непосредственно - `‘Author’` или `Author`. Если модель находится в другом приложении можно указать путь следующим образом - `‘books.Author’` или `books.Author`, соответственно. Также можно создать рекурсивную связь на саму модель, используя аргумент - `‘self’`.
- **on_delete** - когда объект, на который ссылается ForeignKey, удаляется, Django будет эмулировать поведение SQL-ограничения, указанного в аргументе `on_delete`. Важно! `on_delete` не создает SQL-ограничений в базе данных. Поддержка каскадных опций на уровне базы данных может быть реализована позже.
    
    Варианты аргументов:
    
    - `models.CASCADE`: Удаляет все связанные объекты, когда удаляется объект, на который ссылается внешний ключ.
    - `models.PROTECT`: Предотвращает удаление объекта, если на него ссылаются внешние ключи, вызывая исключение `ProtectedError`.
    - `models.SET_NULL`: Устанавливает значение поля внешнего ключа в `NULL`, когда удаляется объект, на который оно ссылается. Поле внешнего ключа при этом должно позволять `null`.
    - `models.SET_DEFAULT`: Устанавливает значение поля внешнего ключа равным значению по умолчанию, когда удаляется объект, на который оно ссылается. Поле внешнего ключа должно иметь значение по умолчанию.
    - `models.SET`: Принимает либо конкретное значение, либо вызываемую функцию. Если передается вызываемая функция, то она будет вызвана в момент удаления объекта, и результат ее выполнения будет установлен в качестве значения внешнего ключа.
    - `models.DO_NOTHING`: Ничего не делает при удалении объекта, на который ссылается внешний ключ. Это может привести к нарушению целостности данных в базе данных.
    
    - `models.RESTRICT`: Предотвращает удаление объекта, если на него ссылаются внешние ключи. Есть отличие от `models.PROTECT`.
        
        Позволяет удалять объект в ситуации, когда он также ссылается на другой объект, который подлежит удалению в рамках операции каскадного удаления (`CASCADE`).
        
        ```Python
        class Artist(models.Model):
            name = models.CharField(max_length=10)
        
        
        class Album(models.Model):
            artist = models.ForeignKey(Artist, on_delete=models.CASCADE)
        
        
        class Song(models.Model):
            artist = models.ForeignKey(Artist, on_delete=models.CASCADE)
            album = models.ForeignKey(Album, on_delete=models.RESTRICT)
        ```
        
        `Artist` может быть удален, даже если это подразумевает удаление альбома, на который ссылается `Song`, поскольку `Song` также ссылается на `Artist` через каскадные отношения.
        
- **options**:
    - `**limit_choices_to**`
        
        Используя этот параметр можно задать условие для фильтрации объектов при их выводе в интерфейсе администратора и других формах, использующих поле данной модели.
        
        Аргумент: Принимает Q-объект, словарь или callable (вызываемый объект, например, функцию), что позволяет задать сложные фильтры.
        
        Пример:
        
        ```Python
        from django.db import models
        
        class Author(models.Model):
           name = models.CharField(max_length=100)
           is_active = models.BooleanField(default=True)
        
        class Book(models.Model):
            title = models.CharField(max_length=200)
        		# Ограничивает выбор только активными авторами
            author = models.ForeignKey(
                Author, on_delete=models.CASCADE,
                limit_choices_to={'is_active': True}
            )
        ```
        
    - **`to_field`**
        
        Позволяет задать поле связанного объекта, с которым устанавливается связь. По умолчанию Django использует первичный ключ связанного объекта. Если вы ссылаетесь на другое поле, оно должно иметь значение unique=True.
        
    - `**db_constraint**`
        
        Управляет созданием ограничения для внешнего ключа в базе данных.
        
        Значение по умолчанию `True`. Изменение на `False` снижает целостность данных, но может быть необходимо в следующих случаях:
        
        - Работа с некорректными унаследованными данными
        - Шеринг (распределение) базы данных
        
        Если `False`, попытка доступа к несуществующему связанному объекту вызовет исключение `DoesNotExist`.
        
    - **`swappable`**
        
        Продвинутая настройка с большим количеством информации, которая на данном этапе ещё не разбиралась) По умолчанию `True` и на данном этапе лучше не трогать.
        
    - `related_name` и `related_query_name` будут объяснены ниже.

### Прямые и обратные отношения

**Прямые отношения** создаются от модели, определяющей отношения (та, что содержит ForeignKey) к связываемой модели. От ребёнка к родителю!

Это даёт нам несколько возможностей:

1. Обращаться через атрибут экземпляра модели к объекту, с которым этот экземпляр связан. Звучит сложно, на самом деле просто) смотри пример:
    
    ```Python
    class Post(models.Model):
    
        title = models.CharField(max_length=255)
        content = models.TextField(blank=True)
    		is_published = models.BooleanField(default=True)
        cat = models.ForeignKey('Category', on_delete=models.PROTECT)
    
    
    class Category(models.Model):
    
        name = models.CharField(max_length=100, db_index=True)
        slug = models.SlugField(max_length=100, unique=True)
    ```
    
    При такой системе связей моделей мы можем получить экземпляр класса Post:
    
    ```Python
    some_post = Post.objects.get(pk=1)
    ```
    
    И затем обращаться к **объекту** категории, с которым он связан через атрибут - `cat`.
    
    ```Python
    some_post.cat
    # выведет категорию, с которой связан данный пост.
    
    some_post.cat.name
    # выведет название категории
    
    some_post.cat.slug
    # выведет значение поля slug категории
    ```
    
    При этом атрибут `some_post.cat_id` ссылается не на объект `cat`, а на поле `cat_id` в таблице Post.
    
2. Возможность фильтрации объектов Post, используя категорию.
    
    ```Python
    Post.objects.filter(cat__name='Important')
    # выведет все посты из категории - Важные
    ```
    
      
    

**Обратные отношения** создаются от связываемой модели к той, что определяет отношения (содержит ForeignKey). От родителя к ребёнку!

Что в свою очередь позволяет нам использовать следующие возможности:

1. У экземпляра модели создаётся менеджер с именем по умолчанию - класс определяющей модели с маленькой буквы + _set. Его можно использовать для вывода всех связанных объектов или фильтрации этого вывода.
    
    ```Python
    cat1 = Category.objects.get(pk=1)
    
    # получаем все посты, которые относятся к 1 категории.
    cat1.post_set.all()
    
    # получаем все опубликованные посты из 1 категории
    cat1.post_set.filter(is_published=1)
    ```
    
    Однако, используя параметр related_name у поля ForeignKey, можно задать другое имя для этого менеджера. Например:
    
    ```Python
    class Post(models.Model):
    
        ...
        cat = models.ForeignKey(..., related_name='posts')
    
    
    # используем его в качестве имени менеджера
    cat1 = Category.objects.get(pk=1)
    
    # получаем все посты, которые относятся к 1 категории.
    cat1.posts.all()
    ```
    
    Если `related_name` задан, то такое же значение будет использоваться по умолчанию для `related_query_name` (будет объяснено далее) .
    
2. У нас также есть возможность использовать фильтрацию для объектов связанной модели, используя определяющую модель. По умолчанию для этого используется имя определяющей модели с маленькой буквы. Например:
    
    ```Python
    Category.objects.filter(post__is_published=1)
    # выведет все категории, для которых есть опубликованные посты
    ```
    
    Если мы переопределяли значение `related_name`, то в таком случае нам нужно использовать его.
    
    ```Python
    Category.objects.filter(posts__is_published=1)
    # выведет все категории, для которых есть опубликованные посты
    ```
    
    Но изначально за этот параметр отвечает поле - `related_query_name`, который мы можем задать в ForeignKey.
    
    ```Python
    class Post(models.Model):
    
        ...
        cat = models.ForeignKey(..., related_name='posts', related_query_name='where_posts')
    
    
    Category.objects.filter(where_posts__is_published=1)
    # выведет все категории, для которых есть опубликованные посты
    ```
    
    Для вывода только уникальных записей нужно добавить метод - `distinct()` в конце запроса.
    

### Дополнительные методы родителя.

1. **`add(obj1, obj2, ...)`**: добавляет указанные объекты модели в набор связанных объектов. Например, если у вас есть блог (`Blog` - родительская модель), и вы хотите добавить к нему несколько записей (`Entry` - модель ребёнка - содержит ForeignKey), вы можете использовать этот метод. Каждый объект указывается в качестве аргумента метода.
    
    ```Python
    b = Blog.objects.get(id=1)
    e1 = Entry.objects.get(id=1)
    e2 = Entry.objects.get(id=2)
    b.entry_set.add(e1, e2)
    ```
    
2. **`create(**kwargs)`**: создает новый объект модели, сохраняет его в базе данных и добавляет его в набор связанных объектов. Вы можете передать аргументы для создания объекта в виде ключевых слов (`kwargs`). Метод возвращает только что созданный объект.
    
    ```Python
    b = Blog.objects.get(id=1)
    new_entry = b.entry_set.create(title='New Entry', content='Content of the new entry')
    ```
    
3. `**remove(obj1, obj2, ...)**`: для объектов ForeignKey этот метод существует только в том случае, если null=True. Если связанное поле не может быть установлено в None (NULL), то объект не может быть удален из отношения, не будучи добавленным в другое.
    
    Этот метод удаляет указанные объекты модели из набора связанных объектов (при этом не удаляет сам объект из базы данных). Каждый объект указывается в качестве аргумента метода.
    
    ```Python
    b = Blog.objects.get(id=1)
    e = Entry.objects.get(id=1)
    b.entry_set.remove(e)
    ```
    
4. `**clear()**`: для этого метода действуют те же ограничения на null-True, как у предыдущего. Он удаляет все объекты из набора связанных объектов (при этом не удаляет сами объекты из БД).
    
    ```Python
    b = Blog.objects.get(id=1)
    b.entry_set.clear()
    ```
    
5. `**set(objs)**`: заменяет набор связанных объектов новым набором, переданным в качестве аргумента. Обратите внимание, что все предварительно существующие объекты будут удалены из набора перед добавлением новых объектов.
    
    Этот метод принимает аргумент `clear` для управления тем, как выполнять операцию. Если `False` (по умолчанию), то элементы, отсутствующие в новом наборе, удаляются с помощью `remove()` и добавляются только новые. Если `clear=True`, вместо этого вызывается метод `clear()`, и весь набор добавляется сразу.
    
    ```Python
    b = Blog.objects.get(id=1)
    new_entries = Entry.objects.filter(published=True)
    b.entry_set.set(new_entries)
    ```
    

  

*Мои ощущения, когда всё это разобрала и расписала)

[![](https://memchik.ru/images/templates/mcconaughey_smoke.jpg)](https://memchik.ru/images/templates/mcconaughey_smoke.jpg)

<div class="page-break" style="page-break-before: always;"></div>
