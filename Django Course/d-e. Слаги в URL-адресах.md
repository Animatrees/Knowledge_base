Что такое slug

SlugField

AutoSlugField и unidecode()

Метод save()

Сравнение способов генерации

Использование SlugField в url-маршруте и представлении

get_absolute_url

url tag vs get_absolute_url

### Что такое slug

**Слаги (slug)** - это короткие текстовые метки, обычно используемые в веб-разработке для создания читабельных и оптимизированных для поисковых систем URL-адресов. Они обычно формируются путем преобразования заголовков или других текстовых данных в URL-дружественный формат.

Слаг может содержать только буквы, цифры, знаки подчеркивания и дефисы.

**Преимущества использования слагов:**

1. **Улучшение SEO**: Слаги позволяют включать ключевые слова в URL, что может помочь улучшить SEO и увеличить видимость контента в поисковых системах.
2. **Читаемость URL**: Слаги делают URL-адреса более читаемыми для людей, поскольку они обычно содержат понятные слова или фразы, отражающие содержание страницы.
3. **Уникальность и однозначность**: Слаги обычно создаются на основе заголовков или других уникальных идентификаторов, что гарантирует их уникальность и однозначность.
4. **Удобство использования в ссылках и социальных сетях**: Слаги удобны для передачи и обмена ссылками в социальных сетях и других интернет-ресурсах.
5. **Безопасность и защита от атак**: Использование слагов помогает защитить сайт от некоторых видов атак, таких как атаки инъекцией или кросс-сайтовый скриптинг, так как слаги могут быть легко проверены и очищены от потенциально вредоносного кода.

### SlugField

В Django `SlugField` является полем модели, предназначенным для хранения слага.

**Пример определения поля** `**SlugField**`**:**

```Python
from django.db import models

class MyModel(models.Model):
    title = models.CharField(max_length=100)
    slug = models.SlugField(max_length=150, unique=True)

    def __str__(self):
        return self.title
```

**Обзор основных характеристик** **`SlugField`****:**

- `max_length` (необязательный параметр): Максимальная длина слага. Если не указан, Django использует значение по умолчанию, равное 50 символам.
- `db_index`: Устанавливается в True по умолчанию, что означает, что для этого поля создается индекс в базе данных для оптимизации поиска по слагу.
- `allow_unicode` (опциональный атрибут): Если установлен в True, поле принимает буквы Unicode, кроме ASCII. По умолчанию установлено в False.
- Валидация: `SlugField` использует функции `validate_slug` или `validate_unicode_slug` для валидации значений слага.

### AutoSlugField и unidecode()

Для автоматической генерации слагов в django используется встроенная функция slugify, но она не работает с кириллицей (просто игнорирует символы). Для решения этой проблемы, и автоматического заполнения значения слага на основании другого поля, можно использовать связку - AutoSlugField - unidecode - slugify.

Библиотека `django-autoslug` используется для автоматического создания slug-полей в моделях Django. Она позволяет:

- **Автоматически** генерировать slug-поля из других полей модели.
- **Обеспечивать** уникальность slug-значений.
- **Использовать** пользовательские функции `slugify` для более точной транслитерации.

**Как использовать:**

1. Установите библиотеки `django-autoslug` и `unidecode`:
    
    ```Python
    pip install django-autoslug
    pip install unidecode
    ```
    
2. Импортируйте следующие библиотеки в `models.py`
    
    ```Python
    from autoslug import AutoSlugField
    from unidecode import unidecode
    from django.utils.text import slugify
    ```
    
3. Используйте в модели следующим образом:
    
    ```Python
    # определяем кастомную функцию
    def custom_slugify(value):
        return slugify(unidecode(value))
    
    # используем AutoSlug с кастомной функцией
    class Category(models.Model):
        title = models.CharField(max_length=100)
        slug = AutoSlugField(populate_from='title', slugify=custom_slugify)
    ```
    

> [!important]  
> Используйте этот метод только если уверены, что поле, по которому сформирован слаг в дальнейшем не будет изменяться, так как в дальнейшем такое поле слаг нельзя будет редактировать в админ-панели, а при изменении заголовка, новый слаг сгенерирован не будет.  

### Метод save()

Другим вариантом автоматической генерации слага, является метод save(), который вызывается в момент сохранения объекта. Мы можем прописать в нём необходимую логику для создания слага.

```Python
from unidecode import unidecode
from django.utils.text import slugify


class Category(models.Model):
    title = models.CharField(max_length=100)
    slug = models.SlugField(max_length=100, unique=True)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(str(self.title)))
        super().save(*args, **kwargs)
```

Этот способ перезатирает наши ручные изменения слага в админ-панели, так как он генерируется непосредственно в момент сохранения объект, но его можно улучшить, добавив дополнительную проверку, например:

```Python
    ...
    def generate_slug(self):
        if self.pk is not None:
            old_instance = self.__class__.objects.only('slug').get(pk=self.pk)
            if old_instance.slug != self.slug or old_instance.title == self.title:
                return
        self.slug = custom_slugify(self.title)

    def save(self, *args, **kwargs):
        self.generate_slug()
        super().save(*args, **kwargs)
```

В обоих методах мы используем библиотеку unidecode только для преобразования кириллицы в латиницу. Если в нашем приложении не будет кириллицы, то нам не нужно использовать её)

### Сравнение способов генерации

1. **Использование SlugField и ручное управление слагом**:
    - Плюсы: Полный контроль над значением слага, возможность задавать уникальные и семантически осмысленные слаги.
    - Минусы: Необходимость ручного управления слагами, что может быть трудоемким при большом количестве записей. Риск возникновения дублирующихся слагов. (если не использован параметр unique)
2. **Использование AutoSlugField**:
    - Плюсы: Слаги генерируются автоматически при создании объекта, что экономит время и усилия.
    - Минусы: Слаги могут быть автоматически сгенерированы на основе ограниченного набора полей, что может привести к дублированию или семантически неосмысленным слагам. Слаги изменяются только вручную в базе данных, что может быть неудобным.
3. **Использование SlugField и генерация слага в методе save**:
    - Плюсы: Слаги генерируются автоматически на основе заданной логики, что экономит время. Слаги автоматически обновляются при изменении связанных полей.
    - Минусы: Необходимость реализации логики генерации слагов, что может усложнить код. Риск возникновения дублирующихся слагов, если не предусмотрена проверка уникальности.

> [!important]  
> В целом, третий подход считается наиболее распространенным и рекомендуемым в индустрии. Он обеспечивает баланс между автоматизацией и контролем над генерацией слагов. Однако выбор подхода зависит от требований проекта, объема данных, необходимости уникальных слагов и других факторов.  

### **Использование SlugField в url-маршруте и представлении**

`**models.py**`**:**

```Python
class Article(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255)
```

`**urls.py**`**:**

```Python
from django.urls import path
from .views import article_detail

urlpatterns = [
    path('blog/<slug:article_slug>/', article_detail, name='article_detail'),
]
```

`**views.py**`**:**

```Python
from django.shortcuts import get_object_or_404

def article_detail(request, article_slug):
    article = get_object_or_404(Article, slug=article_slug)
```

### get_absolute_url

Метод `get_absolute_url` - это метод модели, который возвращает абсолютный URL-адрес для объекта этой модели. Он используется для получения URL-адреса, по которому можно просмотреть конкретный объект модели. Этот метод часто используется в шаблонах и представлениях для генерации ссылок на объекты модели.

**Пример использования:**

```Python
from django.db import models
from django.urls import reverse

class Article(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255, unique=True)

    def get_absolute_url(self):
        return reverse('article_detail', kwargs={'article_slug': self.slug})
```

В этом примере `get_absolute_url` возвращает абсолютный URL-адрес для объекта `Article`. Он использует функцию `reverse`, чтобы динамически сгенерировать URL-адрес на основе имени маршрута (`'article_detail'`) и значения слага (`self.slug`) объекта.

После определения метода `get_absolute_url`, его можно использовать в шаблонах или представлениях для создания ссылок на объекты модели. Например:

```HTML
<a href="{{ article.get_absolute_url }}">Ссылка на статью</a>
```

При вызове `get_absolute_url` для объекта `article`, он автоматически вернет URL-адрес, который был определен в методе `get_absolute_url`, что позволит создавать ссылки на этот объект с помощью всего одной строки кода. Это делает код более читаемым и облегчает его поддержку.

### url tag vs get_absolute_url

1. **Универсальность**: `get_absolute_url()` может быть использован не только в шаблонах Django, но и в любом месте кода Python, где требуется получить URL-адрес объекта модели. Это делает его более универсальным и гибким в использовании.
2. **Гибкость**: `get_absolute_url()` позволяет переопределить логику генерации URL-адреса для каждой модели. Это дает возможность использовать различные параметры или алгоритмы для генерации URL-адресов для одной модели в зависимости от конкретных требований приложения.
3. **Поддержка рефакторинга**: Используя `get_absolute_url()`, при изменении имени модели или URL-шаблона не требуется вносить изменения во всех соответствующих местах кода или шаблонов. Логика генерации URL-адреса остается локализованной в одном месте, что упрощает поддержку и развитие приложения.
4. **Повышение читаемости кода**: Использование `get_absolute_url()` делает код более читаемым и понятным. Это также позволяет сделать шаблоны более простыми и лаконичными, так как не нужно явно указывать путь к представлению или маршруту.
5. **Тестируемость**: `get_absolute_url()` можно легко тестировать в рамках unit-тестов, что обеспечивает более надежное и простое тестирование логики генерации URL-адреса для объектов модели.

<div class="page-break" style="page-break-before: always;"></div>
