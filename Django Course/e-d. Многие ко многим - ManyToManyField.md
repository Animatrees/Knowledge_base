Описание связи и дополнительные параметры

Другие варианты использования связи ManyToMany

Методы add, remove, set и т.д.

### Описание связи и дополнительные параметры

Тип связи "Многие ко многим" (или ManyToManyField в Django) представляет отношение, при котором каждый объект одной модели может быть связан с несколькими объектами другой модели, и наоборот.

Синтаксис: `ManyToManyField(to, **options)`

ManyToManyField требует один обязательный аргумент: класс, с которым связана модель - `to`. И имеет опциональные параметры, некоторые из которых уже были разобраны для [[e-b. Один ко многим - ForeignKey]] (related_name, related_query_name, limit_choices_to).

Данный тип связи не имеет параметра `on_delete`, так как это равноправные отношения, в которых нет “родителя” и “ребёнка”, поэтому не нужно задавать какое-то конкретное действие. Однако, при удалении объекта модели будут также удалены все связанные с ним связи в общей таблице.

Также параметр `null` не имеет никакого эффекта, поскольку нет способа потребовать отношения на уровне базы данных.

```Python
from django.db import models


class Topping(models.Model):
    # ...
    pass


class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)
```

По умолчанию Django создает промежуточную таблицу с использованием имени поля "многие ко многим" и имени таблицы модели, которая содержит это поле. Например, если у нас есть модель `Pizza` и модель `Topping`, и мы устанавливаем ManyToMany связь между ними с помощью поля `toppings` в модели `Pizza`, Django создаст промежуточную таблицу, которая будет называться что-то вроде `pizza_toppings`.

Однако некоторые базы данных ограничивают длину имени таблицы. В этом случае Django автоматически укорачивает имена таблиц и добавляет хеш для обеспечения уникальности. Например, промежуточная таблица может быть названа `pizza_toppi_9cdf`.

> [!important]  
> Если вы хотите задать имя промежуточной таблицы вручную, вы можете использовать параметр db_table. Это позволит контролировать имя таблицы и может быть полезным, если вы хотите сделать его более описательным или если у вас есть какие-то особые требования к именам таблиц в вашей базе данных.  

Неважно, в какой модели находится поле ManyToManyField, но вы должны поместить его только в одну из моделей - не в обе. Обычно её помещают в ту модель, которая в дальнейшем будет редактироваться в форме.

Также для этого поля рекомендуется использовать имя во множественном числе, которое будет описывать набор объектов, с которым связана данная модель.

> [!important]  
> Нельзя при создании объекта задавать сразу значения для поля ManyToMany, так как объект сперва должен быть записан в базу данных и ему должен быть присвоен первичный ключ. Иначе система выдаст ValueError:ValueError: "<Pizza: Django lets you build web apps easily>" needs to have a value for field "id" before this many-to-many relationship can be used.Однако, можно использовать метод create() у связанного менеджера, тогда будет создан новый объект, создана связь и затем объект будет возвращен.t1 = Topping(title='tomato')  
new_pizza = t1.pizza_set.create(title="Margarita")  

- `**db_constraint**`: Этот параметр используется в Django для управления тем, будут ли создаваться внешние ключи и уникальные ограничения на уровне базы данных для поля. По умолчанию `db_constraint` установлен в `True`, что означает, что Django создаст соответствующие ограничения в базе данных. Однако, если вы хотите предотвратить создание внешнего ключа на уровне базы данных, вы можете установить `db_constraint=False`. Это может быть полезно, если вы хотите управлять ограничениями на уровне приложения, а не на уровне базы данных, или если вы хотите избежать накладных расходов на поддержание внешних ключей в базе данных.

### **Другие варианты использования связи ManyToMany**

1. Данная связь может быть задана для модели рекурсивно, то есть ссылаться на саму себя (`self`). Например, у нас есть модель, описывающая пользователей, а между пользователями могут устанавливаться дружественные связи, то можно было бы реализовать данные отношения через `ManyToManyField`, которое указывает само на себя.
    
    ```Python
    class UserProfile(models.Model):
        ...
        friends = models.ManyToManyField('self', symmetrical=True)
    ```
    
    Здесь поле `friends` является полем ManyToManyField, связывающим пользователя с другими пользователями (его друзьями), и оно указывает на ту же модель `UserProfile`. Параметр `symmetrical=True` при этом отвечает за создание симметричной связи. Например, если у нас есть пользователи A и B, и они добавили друг друга в качестве друзей, то в случае, если `symmetrical=True`, Django автоматически создаст два отношения: A -> B и B -> A.
    
2. Используя параметр `through`, можно указать модель, которая будет использоваться для управления отношениями "многие-ко-многим". Затем вы можете поместить дополнительные поля в промежуточную модель. Эти дополнительные поля могут быть полезны в ситуации, когда вам нужно не только создать связь, но и указать какую-то информацию, которая относится к этой связи.
    
    Например, используя промежуточную модель `Membership`, мы можем указать дату присоединения человека к группе и причину его приглашения. Данная информация сама по себе не относится ни к человеку, ну к группе, она относится именно к связи. Поэтому именно здесь и следует добавить необходимые поля:
    
    ```Python
    from django.db import models
    
    
    class Person(models.Model):
        name = models.CharField(max_length=128)
    
        def __str__(self):
            return self.name
    
    
    class Group(models.Model):
        name = models.CharField(max_length=128)
        members = models.ManyToManyField(Person, through="Membership")
    
        def __str__(self):
            return self.name
    
    
    class Membership(models.Model):
        person = models.ForeignKey(Person, on_delete=models.CASCADE)
        group = models.ForeignKey(Group, on_delete=models.CASCADE)
        date_joined = models.DateField()
        invite_reason = models.CharField(max_length=64)
    ```
    
    При настройке модели-посредника нужно явно указать внешние ключи для моделей, участвующих в отношениях "многие-ко-многим". Это явное объявление определяет, как связаны две модели.
    
    Также существует ограничение, по которому промежуточная модель должна содержать ровно один внешний ключ к исходной модели (source model). Это означает, что в промежуточной модели должно быть одно поле ForeignKey, которое ссылается на модель, с которой устанавливается отношение "многие ко многим". Если у вас есть больше одного внешнего ключа и вы не указали поля через `through_fields`, возникнет ошибка валидации. То же самое относится и к внешнему ключу к целевой модели (target model).
    
    Также можно использовать методы `add()`, `create()` или `set()` для создания отношений, если будут указаны все необходимые поля через `through_defaults`.
    
    ```Shell
    beatles = Group.objects.create(name="The Beatles")
    ringo = Person.objects.create(name="Ringo Starr")
    
    beatles.emebers.add(ringo, through_defaults={"date_joined": date(1960, 8, 1)})
    ```
    
    - `**through_fields**`: При использовании этого параметра вы указываете имена полей в промежуточной модели, которые будут использоваться как внешние ключи для связи с моделями. Это позволяет более гибко настроить связь и указать конкретные поля, если их несколько. Например:
        
        ```Python
        class Person(models.Model):
            name = models.CharField(max_length=100)
            groups = models.ManyToManyField(Group, through='Membership', through_fields=('person', 'group'))
        
        class Group(models.Model):
            name = models.CharField(max_length=100)
        
        class Membership(models.Model):
            person = models.ForeignKey(Person, on_delete=models.CASCADE)
            group = models.ForeignKey(Group, on_delete=models.CASCADE)
            date_joined = models.DateField()
        ```
        

### Методы add, remove, set и т.д.

Дополнительные методы работают аналогичным образом, как мы разбирали ранее для [[e-b. Один ко многим - ForeignKey]]. Но есть несколько различий:

- Здесь эта связь двусторонняя, и может быть использована не только от родительской модели к дочерней, как в FK, но и наоборот (так как в связи многие ко многим нет детей и родителей)).
- Методы remove, clear и set не требуют наличия параметра null=True у поля, ведь, как упоминалось ранее этот параметр не имеет влияния на БД)
- Для отношений "многие-ко-многим" многие методы принимают в качестве аргумента не только экземпляры модели - *objs, но и значения полей, обычно первичных ключей.
- Также можно использовать аргумент `through_defaults`, чтобы указать значения для новых промежуточных экземпляров модели, если это необходимо.

<div class="page-break" style="page-break-before: always;"></div>
