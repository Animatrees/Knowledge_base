Динамические URL

Конвертеры

Зачем нужны конвертеры

Типы конвертеров

Валидация и Методы конвертеров

Как создать кастомный конвертер

Функция re_path

### **Динамические URL**

Динамический URL – это адрес страницы веб-ресурса, который генерируется динамически на сервере, в момент поступления запроса от пользователя.

В отличие от статических URL-адресов, которые всегда фиксированы и указывают на конкретные файлы на сервере, динамические URL-адреса меняются в зависимости от параметров запроса.

Пример:

- Статический URL: `about/` всегда будет отображать страницу "О нас".
- Динамический URL: `articles/<int:article_id>/` может отображать разные страницы со статьями, в зависимости от номера статьи. На основе этого параметра сервер может динамически сгенерировать содержимое страницы, предоставляя информацию о конкретной статье из базы данных.

Преимущества динамических URL включают в себя более гибкую и масштабируемую архитектуру веб-приложений, возможность легко изменять и добавлять новый контент, а также улучшенную оптимизацию для поисковых систем благодаря уникальным и информативным URL.

### **Конвертеры**

Конвертер в Django - это механизм, который определяет, как данные из URL должны быть извлечены, валидированы и преобразованы в Python-объекты для передачи в представления.  
Каждый конвертер задает правила соответствия для определенной части URL-шаблона, определяя ожидаемый формат данных с помощью регулярных выражений, и обеспечивает автоматическое извлечение и преобразование данных для обработки в представлениях.  

Пример использования конвертера `**int**` в URL-шаблоне:

```Python
# urls.py (for app)
from django.urls import path
from . import views


urlpatterns = [
    path('articles/<int:article_id>/', views.article_detail, name='article_detail'),
]
```

В этом примере мы определяем URL-шаблон, который ожидает URL вида `**/articles/<число>/**`, где `**<число>**` является идентификатором статьи. Именно использование конвертера `**int**` перед именем переменной (`**article_id**`), указывает Django на то, что значение этой переменной должно быть целым числом.

> _*Аргумент_ _`**name**`_ _в URL-шаблоне используется для задания уникального имени маршрута. Это имя может быть использовано в других частях приложения для ссылок на этот маршрут, вместо жестко закодированных URL. Использование именованных маршрутов делает код более гибким и поддерживаемым.  
> В примере выше__`**name='article_detail'**`_ _задает имя маршрута как "article_detail". Теперь, если в другом месте приложения вам нужно создать ссылку на детали статьи, вы можете использовать этот именованный маршрут, а не жестко прописывать URL.  
>   
> Пример использования в шаблоне:  
> <a href="{% url 'article_detail' article_id=123 %}">Подробности статьи</a>  
>   
> Здесь__`**{% url 'article_detail' article_id=123 %}**`_ _создает URL для маршрута с именем "article_detail" с передачей значения_ _`**article_id=123**`__. Если в будущем маршрут изменится (например, добавится префикс), вам не нужно будет изменять все места, где вы используете этот URL вручную._

Когда запрос с URL `**/articles/123/**` поступает на сервер, Django автоматически извлекает значение `**123**` и преобразует его в целое число. Затем это значение передается в представление `**views.article_detail**` в качестве аргумента `**article_id**`. Таким образом, в представлении мы можем использовать это число для получения и отображения подробностей о статье с идентификатором `**123**`.

Например:

```Python
# views.py
from django.http import HttpResponse, HttpRequest


def article_detail(request: HttpRequest, article_id: int) -> HttpResponse:
    return HttpResponse(f'Статья №{article_id}')
```

В случае, если в URL передается значение, которое не является целым числом, например `**/articles/abc/**`, Django выдаст ошибку 404 (страница не найдена), так как не сможет сопоставить этот URL с определенным представлением из-за несоответствия типа данных ожидаемому.

### Зачем нужны конвертеры

1. **Параметризация URL**: Конвертеры позволяют создавать динамические URL-шаблоны, которые могут принимать различные значения. Это делает URL более гибкими и масштабируемыми.
2. **Извлечение данных из URL**: Конвертеры позволяют извлекать значения из URL и передавать их в представления Django для дальнейшей обработки. Например, извлечение идентификатора пользователя или товара из URL запроса.
3. **Валидация данных**: Конвертеры также могут использоваться для валидации данных, полученных из URL, чтобы убедиться, что они соответствуют определенным критериям. Например, проверка, что идентификатор пользователя является целым числом.
4. **Удобство использования**: Использование конвертеров делает определение и обработку URL более простой и удобной. Они позволяют четко указать ожидаемый формат данных в URL и автоматически преобразовать его в нужный тип данных в представлении.

### Типы конвертеров

В Django существует несколько встроенных типов конвертеров, которые используются для обработки динамических частей URL-шаблонов. Вот подробное описание каждого типа конвертера:

1. **int**: Этот конвертер преобразует часть URL в целое число. Например, `**<int:article_id>**` соответствует только целым числам.
2. **str**: Конвертер `**str**` принимает любую строку в URL, включая буквы, цифры и специальные символы, но исключая слэши /. Например, `**<str:article_name>**` будет сопоставлен со строкой, содержащей текст или символы.
3. **slug**: Этот конвертер принимает только буквенно-цифровые символы, дефисы и знаки подчеркивания. Это удобно для создания URL-адресов, которые хорошо читаются человеком и хорошо подходят для SEO.
4. **uuid**: Конвертер `**uuid**` соответствует UUID (уникальным идентификаторам), которые обычно используются для идентификации объектов в приложениях.
5. **path**: Этот конвертер используется для сопоставления всего оставшегося пути URL. Он принимает все символы, включая слэши, и используется, когда вам нужно сопоставить URL, содержащий несколько сегментов.

### Валидация и Методы конвертеров

Конвертер валидирует данные путем сравнения их с заданным регулярным выражением, которое определено в атрибуте `regex`. Это регулярное выражение определяет ожидаемый формат данных.

Во встроенных конвертерах, таких как `int`, `str`, `slug` и т.д. Django использует стандартные регулярные выражения для соответствующих типов данных. Например, для `int` ожидается строка, содержащая только цифры, и регулярное выражение для этого будет `r'\d+'`, что означает "одна или более цифр". Таким образом, если значение из URL содержит только цифры, оно будет считаться валидным для конвертера `int`, иначе Django выдаст ошибку 404 (страница не найдена).

**Методы:**

1. **to_python(self, value)**: Этот метод принимает значение из URL (всегда строковое значение) и преобразует его в Python-объект. Например, если ваше представление, для дальнейшей работы со значением, ожидает целое число, этот метод может преобразовывать строку в целое число. Если значение не может быть преобразовано, метод может выбрасывать исключение, чтобы указать на ошибку.
2. **to_url(self, value)**: Этот метод выполняет обратное преобразование: принимает Python-объект и преобразует его обратно в строку, которая будет использоваться в URL.

Вот пример простого конвертера, который преобразует строку в верхний регистр и наоборот:

```Python
class UpperLowerConverter:
    def to_python(self, value):
        return value.lower()

    def to_url(self, value):
        return value.upper()
```

В этом примере `**to_python**` принимает значение из URL и возвращает его в нижнем регистре, а `**to_url**` принимает значение Python и возвращает его в верхнем регистре. Таким образом, если вы используете этот конвертер в URL-шаблоне, он будет автоматически преобразовывать значения между верхним и нижним регистром при обработке запросов.

### Как создать кастомный конвертер

На примере конвертера, который будет проверять, что в URL адресе содержится год (4-х значное число).

1. Создайте файл `converters.py` в каталоге приложения, затем в этом файле создайте класс `FourDigitYearConverter` и добавьте в него регулярное выражение для проверки данных:
    
    ```Python
    \#converters.py (for app)
    
    class FourDigitYearConverter:
        regex = r'\d{4}'
    		
    		# методы to_python и to_url в данном случае являются опциональными
    		def to_python(self, value):
            return int(value)
    
        def to_url(self, value):
            return str(value)
    ```
    
    В текущем примере, регулярное выражение определяет, что ожидается 4 цифры. Когда Django обрабатывает URL-запрос, он сначала пытается сопоставить значение из URL с регулярным выражением конвертера.  
    Если значение соответствует регулярному выражению, Django считает его соответствующим конвертеру, вызывает метод to_python и возвращает преобразованное значение в представление. Если значение не соответствует регулярному выражению, Django выдает ошибку.  
    
2. Импортируйте файл с конвертерами в `urls.py`.
3. Импортируйте функцию `register_converter`.
4. Зарегистрируйте конвертер, используя функцию `register_converter`.
5. Пропишите в `path` шаблон для конвертера в `urls.py`:
    
    ```Python
    \#urls.py (for app)
    
    from . import converters
    from django.urls import path, register_converter
    from . import views
    
    # регистрируем конвертер с именем year4
    register_converter(converters.FourDigitYearConverter, 'year4')
    
    # задаём шаблон маршрута, используя наш конвертер
    urlpatterns = [
        path('archive/<year4:year>/', views.archive, name='archive'),
    ]
    
    ```
    
    Теперь URL-шаблон `/archive/2022/` будет сопоставлен представлению `archive`, только если год будет четырехзначным числом. Если значение не соответствует формату, Django выдаст ошибку 404.
    

### Функция re_path

`**re_path**` - применяется для создания URL-шаблонов с использованием регулярных выражений (аналог конвертеров, но в более простом виде).  
Эта функция позволяет более гибко определять правила соответствия URL, используя регулярные выражения вместо фиксированных строк.  

Основные аргументы `**re_path**`:

- **pattern**: Регулярное выражение, определяющее формат URL. Может содержать группы для извлечения значений.
- **view**: Представление, которое будет вызвано при соответствии URL-шаблону.
- **kwargs (необязательно)**: Дополнительные параметры, которые будут переданы в представление.
- **name (необязательно)**: Имя URL-шаблона, которое может быть использовано для создания ссылок в коде приложения.

Пример использования `**re_path**`:

```Python
from django.urls import re_path
from . import views

urlpatterns = [
    re_path(r'^articles/(?P<year>\d{4})/$', views.article_archive, name='article_archive'),
]
```

В этом примере `**re_path**` используется для создания URL-шаблона, который соответствует строке вида `**/articles/2022/**`. Регулярное выражение `**(?P<year>\d{4})**` извлекает четырехзначный год и передает его в представление `**views.article_archive**` в качестве аргумента `**year**`.

<div class="page-break" style="page-break-before: always;"></div>
