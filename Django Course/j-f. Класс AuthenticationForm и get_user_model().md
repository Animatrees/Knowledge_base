Описание

Поля, атрибуты и методы

Класс Meta

get_user_model()

### Описание

Класс `AuthenticationForm` в Django играет ключевую роль в процессе аутентификации пользователей. Он представляет собой форму, которая принимает имя пользователя и пароль, и проверяет их на правильность. Этот класс является базовым для создания форм аутентификации и может быть расширен и кастомизирован под конкретные нужды приложения.

**Преимущества использования** **`AuthenticationForm`****:**

1. Готовая реализация: `AuthenticationForm` предоставляет готовую реализацию формы аутентификации, что избавляет разработчика от необходимости писать ее с нуля.
2. Валидация данных: Класс автоматически выполняет валидацию введенных пользователем данных, проверяя их на соответствие требованиям (например, максимальная длина имени пользователя).
3. Обработка ошибок: `AuthenticationForm` имеет встроенные сообщения об ошибках для различных случаев (неверный логин/пароль, неактивный аккаунт), что упрощает обработку и отображение ошибок пользователю.
4. Расширяемость: При необходимости, класс можно расширить и кастомизировать, переопределив его методы и добавив новую функциональность.

**Пример использования:**

```Python
class LoginUserForm(AuthenticationForm):
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
```

Мы можем наследоваться от данного класса, чтобы изменить стиль отображения полей или переопределить логику его методов.

### Поля, атрибуты и методы

**Поля класса:**

1. `username`: Поле типа `UsernameField` для ввода имени пользователя. Использует виджет `TextInput` с атрибутом `autofocus=True`, что означает автоматическую фокусировку на этом поле при загрузке страницы.
2. `password`: Поле типа `CharField` для ввода пароля. Имеет метку `'Password'`, не удаляет начальные/конечные пробелы (`strip=False`) и использует виджет `PasswordInput` с атрибутом `autocomplete="current-password"` для автозаполнения текущего пароля браузером.

**Атрибуты класса:**

1. `error_messages`: Словарь, содержащий сообщения об ошибках для различных ситуаций:
    - `'invalid_login'`: Сообщение об ошибке при вводе неправильного имени пользователя или пароля. Включает в себя переменную `%(username)s`, которая будет заменена на метку поля `username`.
    - `'inactive'`: Сообщение об ошибке, если аккаунт пользователя неактивен.
2. `request`: Атрибут для хранения объекта запроса (request), переданного в конструктор класса. Используется для доступа к сессии и другим данным запроса.
3. `user_cache`: Атрибут для хранения объекта пользователя, полученного после успешной аутентификации. Инициализируется значением `None`.
4. `username_field`: Атрибут для хранения объекта поля имени пользователя модели пользователя. Получается из `UserModel._meta.get_field(UserModel.USERNAME_FIELD)`.

**Методы класса:**

1. `__init__(self, request=None, *args, **kwargs)`: Конструктор класса. Принимает объект запроса `request`, а также любые дополнительные позиционные и именованные аргументы. Инициализирует атрибуты `request` и `user_cache`, вызывает конструктор родительского класса. Устанавливает максимальную длину и метку для поля `username` на основе настроек модели пользователя.
2. `clean(self)`: Метод для валидации и очистки данных формы. Получает значения полей `username` и `password` из `cleaned_data`. Если оба значения присутствуют, вызывает метод `authenticate` для аутентификации пользователя. Если пользователь не найден, вызывает метод `get_invalid_login_error` для получения ошибки. Если пользователь найден, вызывает метод `confirm_login_allowed` для проверки, разрешен ли вход данному пользователю. Возвращает очищенные данные формы.
3. `confirm_login_allowed(self, user)`: Метод для проверки, разрешен ли вход данному пользователю. По умолчанию проверяет, что аккаунт пользователя активен (`is_active=True`). Если нет, вызывает `ValidationError` с сообщением об ошибке. Этот метод может быть переопределен в подклассах для реализации пользовательской логики проверки разрешения на вход.
4. `get_user(self)`: Метод для получения объекта пользователя из кеша `user_cache`, который был установлен в методе `clean` после успешной аутентификации.
5. `get_invalid_login_error(self)`: Метод для получения ошибки `ValidationError` с сообщением о неверном имени пользователя или пароле. Включает в себя переменную `%(username)s`, которая заменяется на метку поля `username`.

### Класс Meta

С классом `AuthenticationForm` можно также использовать все атрибуты, которые мы рассматривали [[h-f. Формы, связанные с моделями]] на этапе создания формы, связанной с моделью. Единственный нюанс заключается в том, что для атрибута model рекомендуется не прямо прописывать класс модели, который отвечает за пользователя, а использовать функцию - `get_user_model()`.

### get_user_model()

Функция `get_user_model()` в Django используется для получения текущей модели пользователя, которая определена в настройках проекта. Эта функция возвращает класс модели пользователя, который может быть использован для создания экземпляров пользователей, выполнения запросов к базе данных и других операций, связанных с пользователями.

Несколько причин, почему рекомендуется использовать `get_user_model()` вместо прямого указания модели пользователя (например, `User`) в модели формы аутентификации и в других местах проекта:

1. **Гибкость и расширяемость:**
    - Django позволяет определить пользовательскую модель пользователя, отличную от стандартной модели `User`.
    - Если в проекте используется пользовательская модель пользователя, то прямое указание `User` приведет к ошибкам и несовместимости.
    - Использование `get_user_model()` гарантирует, что всегда будет получена правильная модель пользователя, независимо от того, является ли она стандартной или пользовательской.
2. **Поддержка переопределения модели пользователя:**
    - В файле настроек Django (`settings.py`) можно указать пользовательскую модель пользователя с помощью настройки `AUTH_USER_MODEL`.
    - Если в будущем возникнет необходимость изменить модель пользователя, то достаточно будет обновить значение `AUTH_USER_MODEL`, и все места, где используется `get_user_model()`, автоматически будут использовать новую модель.
3. **Согласованность и поддержка:**
    - Использование `get_user_model()` гарантирует, что во всем проекте будет использоваться одна и та же модель пользователя.
    - Это упрощает поддержку и рефакторинг кода, так как нет необходимости вручную обновлять множество мест при изменении модели пользователя.
4. **Следование рекомендациям Django:**
    - Документация Django рекомендует использовать `get_user_model()` вместо прямого указания модели пользователя.
    - Следование этой рекомендации делает код более совместимым и соответствующим лучшим практикам разработки на Django.

**Пример использования** **`get_user_model()`** **в модели формы аутентификации:**

```Python
from django import forms
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import AuthenticationForm

class CustomAuthenticationForm(AuthenticationForm):
    class Meta:
        model = get_user_model()
        fields = ('username', 'password')
```

<div class="page-break" style="page-break-before: always;"></div>
