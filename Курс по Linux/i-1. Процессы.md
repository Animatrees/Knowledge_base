Описание процесса

Жизненный цикл процесса

Просмотр процесса

Типы процессов

Процесс INIT

### Описание процесса

Процесс представляет собой выполнение определенной программы или задачи в операционной системе. Процесс является экземпляром запущенной программы, обладающим собственным адресным пространством, идентификатором процесса (PID), таблицей открытых файлов, стеком вызовов и другими характеристиками. Каждый процесс в системе работает в своем собственном изолированном пространстве памяти.

### Жизненный цикл процесса

1. **Создание:** Процесс начинается с создания. Обычно это происходит путем вызова системного вызова `**fork()**` или `**clone()**`, который создает копию текущего процесса. Новый процесс становится потомком с тем же кодом и данными, что и родительский процесс.
2. **Замена:** После создания новый процесс может заменить свой код и данные на другие с помощью системного вызова `**exec()**`. Это позволяет процессу загрузить и выполнить другую программу.
3. **Ожидание:** Родительский процесс может использовать системный вызов `**wait()**` для ожидания завершения выполнения своего потомка. Это позволяет родителю получить информацию о статусе завершения потомка.
4. **Выполнение:** Потомок выполняет определенные действия в своем адресном пространстве. Это может включать в себя чтение данных, запись файлов, выполнение вычислений и другие задачи.
5. **Завершение:** Процесс потомка завершает свою работу, когда выполнил все свои задачи или когда происходит какая-то ошибка. Он может выйти из своего кода с помощью системного вызова `**exit()**`, который указывает код завершения.
6. **Передача информации о завершении:** Ядро передает информацию о завершении потомка родительскому процессу, включая идентификатор потомка (PID) и код завершения.
7. **Освобождение ресурсов:** После завершения потомка ядро освобождает ресурсы, занимаемые им в таблице процессов, включая освобождение PID.

### Просмотр процесса

Директория `**/proc/**` представляет собой виртуальную файловую систему, предназначенную для предоставления информации о текущем состоянии ядра и процессов в системе. Каждый файл и поддиректория в `**/proc/**` представляют собой интерфейс для доступа к различным параметрам, статистике и настройкам, связанным с работой ядра и выполняющимися процессами.

Команда `**ls -l /proc/ | wc -l**` используется для подсчета количества файлов и поддиректорий в директории `**/proc/**`.

Команда **`ls -ld /proc/* | grep <user_name>`** отображает все процессы пользователя.

Команда `**ps -elf**` используется для отображения информации о процессах.

- `**-e**`: Выводит информацию обо всех процессах, а не только об тех, которые принадлежат текущему терминалу.
- `**-l**`: Выводит дополнительные детали в виде расширенного формата, включая более подробную информацию о процессе.
- `**-f**`: Выводит полный формат, который включает дополнительные поля, такие как идентификатор процесса (PID), PPID (родительский PID), UID (идентификатор пользователя) и другие.

Команда **`ps -aux`** аналог команды **`ps -elf`**.

Расшифровка вывода команды:

1. **F**: Отображает флаги, которые представляют состояние процесса.
2. **S**: Показывает состояние процесса:
    - **Running (R):** Процесс активен и выполняется на процессоре. Он может быть на переднем или фоновом плане, но в данный момент использует ресурсы процессора.
    - **Sleeping (S):** Процесс находится в режиме ожидания, когда он не активен и временно остановлен. Это может быть прерываемый сон (interruptible sleep), когда процесс может быть пробужден в ответ на сигнал, или непрерываемый сон (uninterruptible sleep), когда процесс не может быть прерван и ожидает завершения операции ввода-вывода.
    - **Interruptible Sleep (I):** Это прерываемое состояние сна, в котором процесс ожидает какого-либо события, например, завершение операции ввода-вывода или получение сигнала. В отличие от непрерываемого сна, этот режим может быть прерван поступающим сигналом.
    - **Uninterruptible Sleep (D):** Процесс находится в непрерываемом сне и ожидает завершения операции ввода-вывода, например, чтение данных с жесткого диска. В этом состоянии процесс не может быть прерван и ожидает завершения операции.
    - **Stopped (T):** Процесс был приостановлен (stopped), часто из-за сигнала, такого как SIGSTOP. В этом состоянии процесс не выполняется и ожидает возобновления.
    - **Zombie (Z):** Процесс завершил выполнение, но его родительский процесс еще не вызвал системный вызов `**wait**` для сбора статуса завершения. Запись о завершенном процессе остается в таблице процессов до тех пор, пока его родительский процесс не получит статус завершения и не выполнит необходимые действия для освобождения ресурсов, занимаемых процессом-зомби.
3. **UID**: Идентификатор пользователя, которому принадлежит процесс.
4. **PID**: Идентификатор процесса.
5. **PPID**: Идентификатор родительского процесса.
6. **C**: Процент использования CPU процессом.
7. **PRI**: Приоритет процесса.
8. **NI**: Показывает приоритет, который назначен процессу.
9. **ADDR**: Адрес или адреса процесса в виртуальной памяти.
10. **SZ**: Размер процесса в килобайтах.
11. **WCHAN**: Имя функции, в которой заблокирован процесс.
12. **STIME**: Время запуска процесса.
13. **TTY**: Терминал, с которым связан процесс.
14. **TIME**: Общее время процессора, затраченное процессом.
15. **CMD**: Команда, запустившая процесс.

Команда `**pstree**` используется для отображения дерева процессов в системе. Она показывает связи между процессами, позволяя визуально представить их иерархию.

### Типы процессов

1. **Родитель (Parent Process):**
    
    Это процесс, который создал другой процесс. В иерархии процессов каждый процесс, кроме процесса init (PID 1), имеет родителя. Обычно родительский процесс отслеживает состояние и завершение своих дочерних процессов.
    
2. **Потомок (Child Process):**
    
    Потомок - это процесс, созданный другим процессом, который становится его родителем. Потомок наследует ресурсы и атрибуты от своего родительского процесса и может создавать собственные дочерние процессы.
    
3. **Сирота (Orphan)**:
    
    Сирота - это процесс, который был создан родительским процессом, но его родитель завершился до завершения потомка. В таком случае процесс-сирота становится дочерним процессом процесса init (PID 1).
    
4. **Зомби (Zombie)**:
    
    Зомби - это процесс, который завершил выполнение, но его родительский процесс еще не вызвал функцию wait() для получения кода завершения. Зомби не выполняет никаких действий и занимает незначительные системные ресурсы. Он должен быть "убран" из системы путем вызова wait() его родительским процессом.
    
5. **Демон (Daemon)**:
    
    Демон - это фоновый процесс, который работает в фоновом режиме без прямого взаимодействия с пользователем. Демоны обычно создаются при загрузке системы и могут выполнять различные служебные функции, такие как обслуживание запросов клиентов или периодические задачи.
    
    > _Мне была интересна история выбора именно такого названия и, собственно, далее выдержка из Википедии))  
    >   
    > _  
    > Этот термин был придуман программистами проекта MAC Массачусетского технологического института . По словам Фернандо Х. Корбато , который работал над проектом MAC в 1963 году, его команда была первой, кто использовал термин «демон», вдохновленный демоном Максвелла , воображаемым агентом в физике и термодинамике , который помогал сортировать молекулы, заявив: «Мы причудливо начали использовать слово «демон» для описания фоновых процессов, которые неустанно работали над выполнением системных задач».  
    > Системы Unix унаследовали эту терминологию. Демон Максвелла согласуется с интерпретацией демона в греческой мифологии как сверхъестественного существа, действующего на заднем плане.  
    

### Процесс INIT

Первым процессом, который запускается в пользовательском пространстве, является init. Init-процесс отвечает за инициализацию системы и запуск основных служб. Он загружает различные системные службы и процессы, включая службы для сети, файловых систем, аутентификации и другие.

В современных дистрибутивах Linux часто используется systemd в качестве init-системы. systemd позволяет одновременно запускать независимые сервисы и процессы, что ускоряет загрузку системы. Это достигается за счет параллельного выполнения задач и их зависимостей.

<div class="page-break" style="page-break-before: always;"></div>
