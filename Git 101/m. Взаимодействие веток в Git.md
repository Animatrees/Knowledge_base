Слияние веток (git merge)

Ребейз веток (git rebase)

Перемещение по истории с помощью относительных ссылок

Cherry-pick vs rebase -i

[![](https://cdn.matt-rickard.com/images/2022/08/squash.jpeg)](https://cdn.matt-rickard.com/images/2022/08/squash.jpeg)

**Ветвление в Git** - одна из ключевых концепций, которая позволяет эффективно работать над разными функциями или исправлениями ошибок независимо от основного кода. Каждая ветка представляет собственную линию разработки с отдельной историей коммитов. Когда функциональность готова, ветка может быть объединена с основной веткой.

Для объединения двух веток используются команды **слияния (merge)** и **ребейзинга (rebase)**.

### Слияние веток (git merge)

[![](https://i.stack.imgur.com/eWwAH.gif)](https://i.stack.imgur.com/eWwAH.gif)

Команда `git merge` используется для объединения другой ветки в текущую. Обычно вы находитесь в главной ветке, например `master`, и выполняете слияние тематической ветки:

```Shell
git merge feature-branch
```

Git определяет общего предка для обеих веток и применяет изменения из тематической ветки поверх кода главной ветки. В результате образуется специальный коммит слияния (merge commit), который имеет две родительские записи - по одной на каждую из объединенных веток.

Если изменения не конфликтуют, слияние происходит автоматически. В случае конфликтов Git оставляет специальные маркеры в файлах, и вы должны вручную их разрешить, указав, какие изменения следует оставить.

Вы можете выполнить слияние двух веток, не переходя на одну из них, используя команду `git merge` вместе с именами веток.

```Shell
git merge <branch1> <branch2>
```

Где `<branch1>` и `<branch2>` - это имена веток, которые вы хотите слить.

Предположим, у вас есть две ветки: `master` и `feature`. Вы можете выполнить слияние ветки `feature` в ветку `master`, не переходя на `master`, используя следующую команду:

```Shell
git merge master feature
```

### Ребейз веток (git rebase)

[![](https://miro.medium.com/v2/resize:fit:1400/0*JRt9VF_osaAoVwKg.gif)](https://miro.medium.com/v2/resize:fit:1400/0*JRt9VF_osaAoVwKg.gif)

Команда git rebase переносит изменения из одной ветки на другую путем создания новой линии истории. Представим, есть ветка feature, на которой вы работали над новой функциональностью:

```Shell
git rebase master
```

Последняя команда берет все коммиты с ветки feature и помещает их в новую историю поверх текущей головы ветки master. Получается линейная история без дополнительных коммитов слияния.

Для того, чтобы не переходить на ветку, но иметь возможность выполнить её перебазирование, можно использовать команду со следующим синтаксисом `git rebase <base_branch> <branch>`, где `<base_branch>` это то, куда будет перебазирована ветка, а `<branch>` указание какая ветка будет перебазирована.

Ребейз часто предпочтительнее слияния, так как дает более чистую и понятную историю. Однако его не следует применять к общедоступным или уже слитым веткам, поскольку это изменяет идентификаторы коммитов.

### Перемещение по истории с помощью относительных ссылок

Git позволяет перемещаться по истории коммитов, используя относительные ссылки. Например:

```Shell
git checkout HEAD~3  # Переход на 3 коммита назад от текущего
git checkout master~5  # Переход на 5 коммитов назад от ветки master
git checkout HEAD^ # Переход на предыдущий коммит
```

Так же как тильда (~), каретка (^) принимает номер после себя.

Но в отличие от количества коммитов, на которые нужно откатиться назад (как делает `~`), номер после `^` определяет, на какого из родителей мерджа надо перейти. Учитывая, что мерджевый коммит имеет двух родителей, просто указать `^` нельзя.

Git по умолчанию перейдёт на "первого" родителя коммита, но указание номера после `^` изменяет это поведение.

Также можно одновременно использовать тильду и каретку, например, `HEAD~^2~2` - переходим сперва на один коммит назад, потом на второго родителя этого коммита и от родителя ещё два коммита назад.

### Cherry-pick vs rebase -i

**Cherry-pick** используется для применения отдельных коммитов из одной ветки в другую:

[![](https://i.stack.imgur.com/j2D9C.gif)](https://i.stack.imgur.com/j2D9C.gif)

```Shell
git cherry-pick <commit-hash>
```

Полезно, когда нужно добавить небольшое исправление в главную ветку, не внося все изменения целиком.

**Процедура добавления произвольных коммитов в текущую ветку:**

1. Выберите коммит, который вы хотите применить к текущей ветке. Обычно это делается с помощью просмотра истории коммитов с помощью `git log`.
2. Используйте команду `git cherry-pick <commit_hash>`, чтобы применить выбранный коммит к текущей ветке.
    
    Git автоматически создаст новый коммит, содержащий изменения выбранного коммита.
    
3. Если в процессе применения коммита возникают конфликты существующих изменений, вам потребуется разрешить их вручную, как при слиянии веток.
4. После разрешения конфликтов закончите операцию командой `git cherry-pick --continue`, чтобы завершить применение выбранного коммита.
    
    В противном случае, если вы решили прервать операцию, используйте `git cherry-pick --abort`.
    

Интерактивный **ребейз (**`**git rebase -i**`**)** позволяет более тонко управлять коммитами перед выполнением ребейза. При его запуске откроется текстовый редактор, где можно изменять порядок коммитов, объединять, разделять или вовсе удалять их. Это дает полный контроль над историей ветки.

[![](https://raw.githubusercontent.com/trentrand/vscode-git-rebase/master/Preview.gif)](https://raw.githubusercontent.com/trentrand/vscode-git-rebase/master/Preview.gif)

**Процедура работы через интерактивный режим rebase:**

1. Запустите команду `git rebase -i <базовый_коммит>`, где `<базовый_коммит>` - это коммит, с которого вы хотите начать переписывание истории.
2. Git откроет текстовый редактор с полным списком коммитов, начиная с `<базового_коммита>`.
    
    Для каждого коммита вы можете выбрать действие (pick, reword, edit, squash, fixup, drop и т. д.), чтобы изменить историю.
    
3. Выберите действия для каждого коммита в соответствии с вашими потребностями. Например, объедините несколько коммитов в один, изменив сообщения, или отбросьте ненужные коммиты.
4. После завершения редактирования списка коммитов сохраните изменения и закройте редактор.
    
    Git применит выбранные вами действия к каждому коммиту поочередно.
    
    Возможно, придется разрешить конфликты, если они возникнут.
    
5. После завершения переписывания истории завершите операцию командой `git rebase --continue`.
    
    В случае возникновения проблем, вы можете отменить операцию с помощью `git rebase --abort`.
    

Таким образом, грамотное использование механизмов слияния, ребейзинга и других инструментов для работы с ветками помогает поддерживать чистую и понятную историю проекта, а также эффективно интегрировать изменения из различных веток.

P.S. у merge есть ещё несколько вариаций, но их разбор уже для самостоятельной работы))

[![](https://miro.medium.com/v2/resize:fit:1400/0*0BgII1PmO8JzjnXD.gif)](https://miro.medium.com/v2/resize:fit:1400/0*0BgII1PmO8JzjnXD.gif)

[![](https://miro.medium.com/v2/resize:fit:720/format:webp/0*GhW5WSCRH1dneU6c.gif)](https://miro.medium.com/v2/resize:fit:720/format:webp/0*GhW5WSCRH1dneU6c.gif)
<div class="page-break" style="page-break-before: always;"></div>