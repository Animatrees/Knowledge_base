```table-of-contents
title: 
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```

## Что такое Exception?

### Описание

Хотя, чаще всего, мы будем сталкиваться с исключениями в контексте работы над ошибками в коде, будет не совсем правильным ставить знак равенства между ними. Исключения скорее события, которые способны изменить поток управления в программе.

Что это означает? Когда наша программа по ходу своего выполнения сталкивается с исключением, она:

1. Либо аварийно завершается стандартным обработчиком исключений. И мы видим в консоли вывод, подобный этому:
    
    ```Python
    Traceback (most recent call last):
      File "/home/.../test.py", line 4, in <module>
        print(get_letter('spam', 4))
              ^^^^^^^^^^^^^^^^^^^^^
      File "/home/.../test.py", line 2, in get_letter
        return word[index]
               ~~~~^^^^^^^
    IndexError: string index out of range
    
    Process finished with exit code 1
    ```
    
2. Либо, в случае если мы предусмотрели обработку исключения, поток управления будет перенаправлен в блок с этой обработкой, где мы сможем произвести нужные нам операции. Например:
    
    ```Python
    while True:
        try:
            x = int(input('Введи целое число: = '))
        except ValueError:
            print('Неверно! Попробуй ещё раз')
        else:
            print(f'Отлично! Твоё число - {x}')
            break
    
    # Вывод:
    Введи целое число: = Hi!
    Неверно! Попробуй ещё раз
    Введи целое число: = 14/1
    Неверно! Попробуй ещё раз
    Введи целое число: = 7
    Отлично! Твоё число - 7
    ```
    

### Роли, которые может выполнять исключение

- **Обработка ошибок**
    
    Это, пожалуй, самая очевидная роль исключений. Когда интерпретатор Python обнаруживает ошибку во время выполнения программы, он генерирует исключение. У нас есть выбор: либо перехватить это исключение и как-то на него отреагировать, либо позволить Python сделать это за нас (что обычно приводит к остановке программы и выводу сообщения об ошибке). Если нам нужно что-то более изящное, чем просто "упасть с ошибкой", мы используем конструкцию try (как в примере выше) для перехвата и обработки исключения.
    
- **Уведомление о событиях**
    
    Исключения - это не только про ошибки. Мы можем использовать их для сообщения о каких-то особых ситуациях в программе. Например, вместо того чтобы возвращать специальное значение из функции поиска (скажем, -1, если элемент не найден), мы можем генерировать исключение. Это избавляет нас от необходимости постоянно проверять возвращаемое значение и делает код более чистым и понятным.
    
- **Упрощение логики программы**
    
    Добавление в код проверок на все случаи жизни может сильно усложнить его и сделать трудночитаемым. Вместо этого мы можем использовать исключения.  
    Основной код остается чистым и фокусируется на "счастливом пути" - обработке корректных данных. А все нестандартные ситуации обрабатываются в блоках except. Это не только упрощает чтение и понимание кода, но и делает его более гибким.  
    
- **Действия при завершении**
    
    Исключения могут выполнять роль "уборщиков", приводя всё в порядок в конце работы программы, независимо от того, завершилась она успешно или нет. С помощью блока `finally` (будет описан подробно далее) можно гарантировать, что такие ресурсы, как файлы или сетевые соединения, будут закрыты, даже если произошла ошибка. Это помогает предотвратить утечки памяти и другие проблемы, которые могут возникнуть при неправильном управлении ресурсами.
    

## Способы вызова исключений

### Автоматический

Как мы уже видели ранее, в Python предусмотрено возникновение ситуаций, в которых программа не может быть выполнена корректно. И при нашей встрече с такими ситуациями, интерпретатор будет вызывать исключения за нас.

Например, если мы попытаемся получить значение из словаря по ключу, которого в этом словаре просто нет, мы получим исключение - **KeyError**.

```Python
def get_value(key):
    some_value = {
        1: 'one',
        2: 'two',
        3: 'three',
    }
    return some_value[key]

print(get_value(4))
print('Программа завершена')

# Вывод:
Traceback (most recent call last):
  File "/home/.../test.py", line 9, in <module>
    print(get_value(4))
          ^^^^^^^^^^^^
  File "/home/.../test.py", line 7, in get_value
    return some_value[key]
           ~~~~~~~~~~^^^^^
KeyError: 4

Process finished with exit code 1
```

И что важно — программа завершает выполнение сразу же, как только было выброшено исключение. Мы не видим в выводе - `'Программа завершена'`.

### Инструкция raise

Способ, который возвращает инициативу в наши руки и позволяет уже нам самим контролировать вызов исключения, является инструкция **raise**.

Сразу хочу обратить ваше внимание на тот факт, что не имеет большого смысла вызывать исключения, которые Python и так бы вызвал для нас, например, применять его следующим образом:

```Python
def get_value(key):
    some_value = {
        1: 'one',
        2: 'two',
        3: 'three',
    }
    if key not in some_value.keys():
        raise KeyError
    return some_value[key]

print(get_value(4))
print('Программа завершена')
```

Эта инструкция полезна в ситуациях, когда наше условие не может быть проверено интерпретатором по умолчанию. Например, если нам нужно убедиться, что полученное число будет входить в указанный нами диапазон:

```Python
def get_final_price(price, discount):
    if discount >= 100 or discount < 0:
        raise ValueError(f'Скидка не может принимать такое значение! - {discount}%')
    return price * ((100 - discount) * 0.01)

print(get_final_price(42, 100))
print('Программа завершена')

# Вывод:
...
ValueError: Скидка не может принимать такое значение! - 100%
```

Инструкция raise может быть прописана несколькими способами:

- `raise SomeError` - после raise указываем только название класса исключения. В таком случае raise сам вызовет конструктор класса SomeError и неявно создаст объект исключения.
- `raise SomeError()` - здесь мы уже явно создаём экземпляр класса исключения и передаём его в raise.
- `raise` - мы можем использовать эту инструкцию совсем без каких-либо аргументов, в таком случае она поднимет предыдущее исключение, с которым мы работали выше (будет объяснено далее).
- `raise SomeError() from OtherError()` - мы можем прямо указать по причине какого исключения мы вызываем текущее исключение (данный пункт также будет рассмотрен подробнее далее).

### Инструкция assert

Ещё один способ вызвать исключение самостоятельно…но есть один нюанс) В отличии от raise, с помощью которого мы можем вызвать любое исключение, **assert** вызывает только исключение типа - **AssertionError**.

Синтаксис и назначение этой инструкции также отличаются от raise. Посмотрим сперва на синтаксис.

```Python
def get_final_price(price, discount):
    assert 0 <= discount < 100, f'Скидка не может принимать такое значение! - {discount}%'
    return price * ((100 - discount) * 0.01)

print(get_final_price(42, 100))
print('Программа завершена')

# Вывод:
...
AssertionError: Скидка не может принимать такое значение! - 100%
```

Для assert возможны два аргумента, причём второй из них не обязательный:

1. Утверждение. Если оно истинно (True), значит проверка прошла успешно, и исключение не вызывается. Если же во время проверки утверждения был получен False, то будет вызвано исключение - **AssertionError.**
2. Доп. аргумент. Мы можем передать здесь любой объект, который будет использоваться при инициализации объекта исключения и отображаться в выводе. Чаще всего это просто строка с описанием, что пошло не так.

> [!important]  
> На первый взгляд может показаться, что это отличная замена инструкции raise, но это не так!  

Во-первых, assert всегда выводит один и тот же тип исключения, а нам всё же нужно получать более содержательные сообщения о проблеме, будь то ошибка типа, значения или открытия файла.

Во-вторых, все проверки assert можно отключить, если запустить интерпретатор с оптимизацией `python -O script.py` или изменением переменной окружения:

```Shell
export PYTHONOPTIMIZE=1
python script.py
```

Также потенциальная опасность в использовании инструкции заключается в том, что если вы случайно передали в assert кортеж:

```Shell
assert (0 <= discount < 100,
        f'Скидка не может принимает такое значение! - {discount}%')
```

То такое условие всегда будет возвращать True (кортеж не пустой, что даёт True при проверке). Правда в python на такой случай добавили оповещение (которое, кстати, отличный пример того, что исключения не только про ошибки, ведь `SyntaxWarning` также наследуется от базового класса Exception).

`SyntaxWarning: assertion is always true, perhaps remove parentheses?`

Итого, **assert** точно не стоит использовать вместо raise. Но эта инструкция всё же довольно полезна и активно применяется для целей тестирования и отладки во время разработки.

## Traceback

Мы уже несколько раз видели его в деле, но так и не разобрались, что это такое)

Вообще дословно это переводится как трассировка стека… мне же нравится переводить его как “**следы**/trace **назад**/back”))

Объект traceback создаётся неявно при поднятии исключения и содержит в себе подробную информацию о файле, строке и вызванной функции, в которой возникло исключение, начиная с самого раннего вызова в цепочке и заканчивая последним.

Когда программа выполняет вызов функции, Python сохраняет этот вызов в стек (где записи хранятся в порядке "последним пришёл — первым ушёл", или LIFO). И traceback будет отображать этот порядок, начиная с самого низа стека до самого верха (most recent call last - самый недавний вызов последний). Например,

```Python
def get_final_price(price, discount):
    if discount >= 100 or discount < 0:
        raise ValueError(f'Скидка не может принимает такое значение! - {discount}%')
    return price * ((100 - discount) * 0.01)

def make_offer():
    get_final_price(42, 100)

print(make_offer())
print('Программа завершена')

# Вывод:
Traceback (most recent call last):
  File "/home/.../test.py", line 23, in <module>
    print(make_offer())
          ^^^^^^^^^^^^
  File "/home/.../test.py", line 21, in make_offer
    get_final_price(42, 100)
  File "/home/.../test.py", line 17, in get_final_price
    raise ValueError(f'Скидка не может принимает такое значение! - {discount}%')
ValueError: Скидка не может принимает такое значение! - 100%

Process finished with exit code 1
```

То есть в самом низу мы можем сразу увидеть место в коде, где было вызвано исключение. Если же нам нужно проследить всю цепочку вызовов, мы идём сверху вниз, начиная с первого вызова функции, и далее просматриваем, что было вызвано в каждом из них.…

Мы можем получить доступ к traceback через третий элемент кортежа, возвращаемого sys.exc_info(), и через атрибут `__traceback__` пойманного исключения.

```Python
import sys

try:
    get_final_price(42, 100)
except Exception as e:
    tb = sys.exc_info()[2]
    print(f'Traceback: {tb}')
    print(f'__traceback__: {e.__traceback__}')
```

> [!important]  
> Таким образом, traceback — очень полезный инструмент, помогающий понять, что пошло не так в программе. Предоставляет разработчику всю необходимую информацию для отладки и исправления ошибок.  

## Как обработать исключение

Механизм ислючений не был бы таким удобным, если бы мы могли их только вызывать, но не обрабатывать. Особенно, если помнить о том, что после вызова исключения программа аварийно завершается… Вероятно это не совсем то поведение, которое мы хотели бы получить, когда с ней взаимодействует обычный пользователь, а не другой разработчик.

Тут нам на помощь приходит связка try/except.

### Try

Когда мы помещаем какую-то часть кода в инструкцию **try**, мы как бы говорим нашему коду “попробуй выполнить это”, а в инструкции **except** мы указываем, что может пойти не так и что с этим “не так” делать дальше)

```Python
def get_letter(word, index):
    return word[index]

try:
    print(get_letter('spam', 4))
except IndexError:
    print('Передан некорректный индекс')
print('Программа завершена')

# Вывод:
Передан некорректный индекс
Программа завершена
```

С блоком try вроде всё просто, помещаем внутрь какую-то операцию, которая потенциально может породить какую-то ошибку (в данном примере я хочу получить букву из слова по индексу). Хорошей практикой считается размещать в этом блоке ровно тот код, от выполнения которого вы ожидаете конкретную ошибку. То есть делать вот так - плохо:

```Python
def get_letter(word, index):
    return word[index]

letters = {}

try:
    print('Ваша буква:')
    letter = get_letter('spam', 4)
    print(letter)
    letters['letter'] += 1
except IndexError:
    print('Передан некорректный индекс')
print('Программа завершена')
```

1. Мы принтуем текст 'Ваша буква:', хотя сама буква не будет выведена, так как в следующей строчке произойдёт IndexError. В данном примере это не то, чтобы критично, но с таким подходом мы могли выполнить какую-то другую операцию, которая плотно зависит от той, что может упасть с ошибкой… Как откатывать изменения обратно? Или может быть не стоит изначально доводить себя до такой ситуации?)
2. Если бы индекс был корректный, то программа бы всё равно упала с другой ошибкой в строчке `letters['letter'] += 1` - KeyError. Словарь-то пустой) Но мы её не отлавливаем и вообще об этом не думаем… Надеюсь общая идея проблемы понятна?

> [!important]  
> В блоке try - указываем только то, что намерены обработать в блоке except.  

### Except

С этим блоком уже поитереснее) Во-первых, у нас есть несколько вариантов задать саму инструкцию:

- `except` - пожалуй, это самый плохой вариант. Но мы можем указать просто except без исключений, которые рассчитываем получить. Почему? Абсолютно все исключения в Python являются наследниками класса `BaseException`. И все они попадут в данный отработчик. Первое, как мы будем обрабатывать исключение, природу которого мы не понимаем? В том плане, что такой обработчик не даёт нам ровным счётом никакой информации о том, какое именно исключение мы поймали.
    
    Второе, вдумайтесь - оно ловит вообще все исключения) Даже те, которые нам не стоило бы ловить. Например, `KeyboardInterrupt` - выбрасывается, когда пользователь прерывает выполнение программы с помощью комбинации клавиш, `SystemExit` — выбрасывается для завершения программы, когда вызывается функция `sys.exit()`...
    
    ```Python
    def get_letter(word, index):
        return word[index]
    
    try:
        index = int(input())
        print(get_letter('spam', index))
    except:
        print('Было отловлено исключение KeyboardInterrupt')
    print('Программа завершена')
    
    # Для выхода в PyCharm - ctrl + d
    # Вывод:
    Было отловлено исключение KeyboardInterrupt
    Программа завершена
    ```
    
- `except Exception` - в данном случае мы уже не отлавливаем системные исключения, стало получше) Но мы всё ещё не понимаем, что именно мы поймали и как с этим быть. Данную конструкцию рекомендуют использовать только в одном месте - оборачивать запуск программы, чтобы она и не упала, но мы как-то получили сигнал, о том, что что-то пошло не так (логгирование или оповещение).
    
    ```Python
    if __name__ == '__main__':
        try:
            main()
        except Exception:
            # делаем что-то, чтобы сообщить о проблеме
            pass  # временно, чтобы блок не был пустым
    ```
    
- `except ValueError` - вот такой случай уже совсем идеальный!) Мы ловим конкретно определённое исключение и будем обрабатывать именно этот случай.
- `except (ValueError, IndexError)` - также мы можем перечислить в скобках несколько исключений, которые планируем отлавливать (например, в случае, если логика их обработки будет совпадать).
    
    ```Python
    def get_letter(word, index):
        return word[index]
    
    try:
        index = int(input())
        print(get_letter('spam', index))
    except (ValueError, IndexError):
        print('Вы ввели некорректное значение')
    print('Программа завершена')
    
    # Если мы получим на входе значение, которое нельзя преобразовать в индекс
    # или индекс, который будет выходить за допустимый диапазон -
    # вывод будет одинаков - 'Вы ввели некорректное значение'
    # не самый шикарный пример) но, чтобы показать идею)
    ```
    
- `except ValueError as e` - в такой конструкции мы всё ещё отлавливаем конкретное исключение, но если оно будет поймано, то его экземпляр будет сохранён в переменной `e`, которую мы можем как-то обработать внутри данного блока. Зачем это может быть нужно, расскажу далее. > [!important]  
    > UPD. Нужно очень внимательно подходить к названию этой переменной) Если у нас за пределами блока try/except была объявлена переменная с таким же названием, то после выполнения except она будет удалена... Переменные внутри блоков try/except имеют ту же область видимости, что и остальной код, так как эти блоки не создают собственной локальной области, как это делают функции или классы. Но в целях управления памятью и предотвращения циклических ссылок, переменная, связанная с исключением, удаляется после завершения блока except.  
    
    ```Python
    error = 404
    try:
        1/0
    except ZeroDivisionError as error:
        print(error)
    print(error)
    
    # Вывод:
    division by zero
    Traceback (most recent call last):
      File "/home/animatrees/PycharmProjects/sup/src/apps/feature/test.py", line 104, in <module>
        print(error)
              ^^^^^
    NameError: name 'error' is not defined. Did you mean: 'OSError'?
    
    Process finished with exit code 1
    ```
    

  

Фух, с вариантами инструкций разобрались. Стоит ещё упомянуть, что после try может идти любое кол-во блоков except… И важно учитывать то, что они проверяются сверху вниз. Что это значит? Исключения это классы, которые могут выстраиваться в иерархию наследования. И если мы в верхнем except укажем родительский класс, то он поймает все исключения своих дочерних классов. Например,

```Python
try:
    1/0
except Exception:
    print('Всё перехватил!')
except ArithmeticError:
    print('Никаких шансов...')
except ZeroDivisionError as e:
    print('До меня очередь не дойдёт никогда =(')
    
# Вывод:
Всё перехватил!
```

Класс Exception родительский класс для ArithmeticError, а ArithmeticError в свою очередь для ZeroDivisionError… И поток управления будет передан именно в блок `except Exception`. Идея похожа на то, что можно наблюдать с большим кол-вом блоков if/elif… То есть правильный порядок должен выглядеть следующим образом:

```Python
try:
    1/0
except ZeroDivisionError:
    print('То то же!')
except ArithmeticError:
    print('Чтож, я подожду, другое исключение)')
except Exception:
    print('По хорошему я вообще не должен здесь быть...')

# Вывод:
То то же!
```

Более конкретные исключения наверху, обобщающие внизу…

А может ли вообще не быть инструкций except? Может, но об этом ~~в следующей серии~~ читайте дальше)

### Else

Если у нас есть блок except, то может быть и else. Здесь мы можем указать инструкции, которые должны выполнится, если никаких исключений во время выполнения кода в блоке try не произошло! Почему нам нужен этот блок? Почему мы не можем просто написать наш код после блока try/except? Ответ прост:

```Python
try:
...выполнить код...
except IndexError:
...обработать исключение...
# Мы сюда попали из-за того, что try потерпел неудачу или же прошел?
```

В блоке else мы можем указать инструкции, которые в явном виде дадут нам понять, что во время выполнения - никаких исключений не произошло. Синтаксис будет выглядеть следующим образом:

```Python
try:
...выполнить код...
except IndexError:
...обработать исключение...
else:
...исключения не возникали...
```

Мы ранее уже немного обсуждали почему не стоит делать так -

```Python
try:
...выполнить код...
...исключения не возникали...
except IndexError:
...обработать исключение...
```

Ещё дополнительная причина - сам код в `...исключения не возникали...` может породить исключение `IndexError`, но код в блоке except не рассчитан на его обработку)

Для инструкции else обязательно наличие хотя бы одной инструкции except!

### Finally

Файнели, мы добрались до **finally**)

Данный блок отвечает за логику, которая должна быть выполнена в любом случае! Не зависимо от того, возникли ли исключения в блоке try или нет. Обычно здесь располагается код, который отвечает за закрытие файлов, разрыв соединений и очистку ресурсов.

```Python
try:
    1 / 0
except ZeroDivisionError:
    print("Ошибка деления на ноль")
finally:
    print("Этот код выполнится всегда")
    
# Вывод:
# Ошибка деления на ноль
# Этот код выполнится всегда
```

> [!important]  
> Внезапное! Инструкция finally может использоваться самостоятельно с инструкцией try без except! В случае возникновения исключения - сначала выполнится код из finally, а потом программа аварийно завершится (если этот try не был вызван в другом try, куда может быть передано исключение). Это связано с тем, что до python 2.5 try/except и try/finally были двумя разными связками инструкций.  

То есть раньше, чтобы получить функциональность, которой мы можем пользоваться сейчас, прибегали к такому приёму:

```Python
try:
	try:
	# основной код
	except SomeError:
	# обрабатываем исключение, если возникло
	else:
	# логика на случай, если нам повезло пройти без исключений
finally:
# очистка ресурсов
```

Сейчас наш код может выглядеть так:

```Python
try:
# основной код
except SomeError:
# обрабатываем исключение, если возникло
else:
# логика на случай, если нам повезло пройти без исключений
finally:
# очистка ресурсов
```

Кстати, обратите внимание, что инструкции try можно вкладывать друг в друга! Это работает и сейчас)

Для таких распространённых случаев, когда нам обязательно нужно закрыть файл, с которым мы работали, если произошла какая-то ошибка, теперь ещё можно использовать диспетчеры контекстов with/as. Но мы не будем их рассматривать в рамках данного туториала.

### try/except или if/else?

Во время чтения вам могла закрасться мысль - а почему бы в ряде случаев не заменить try/except на if/else? А действительно? Почему бы и нет?) У этих подходов, как оказалось, даже есть свои названия))

- **look before you leap** (LBYL) - смотри, прежде, чем прыгнуть.
- **easier to ask forgiveness than permission** (EAFP) - проще попросить прощения, чем разрешения.

Если вкратце, первый подход про использование if/else - мы сперва проверяем условие, а потом что-то делаем, а второй про try/except - мы пытаемся сделать что-то и если нам не повезло, обрабатываем исключение.

> [!important]  
> Важнее всего понять, что в мире python нет такого, что один подход считается лучше, а другой хуже, или один предпочтительнее, а другой нет. У них просто разное назначение, и свои плюсы и минусы.  

Когда-то мне было интересно сравнить эти подходы на скорость выполнения и результаты были следующие - если мы часто сталкиваемся с ситуацией, когда код будет вызывать ошибку, то лучше использовать if/else, и наоборот.

Чтобы узнать об этих подходах подробнее, а также в каких случаях будет предпочтительнее один или другой, очень рекомендую к прочтению следующую [статью](https://realpython.com/python-lbyl-vs-eafp/).

## Цепочки исключений

Во время обработки одного исключения, мы можем вызвать другое исключение! Ну либо оно может возникнуть само по себе…)

Начнём со второго случая. Такое может произойти когда в блоке try возникло исключение, мы перешли в блок except для его обработки, а там получили ещё одно исключение (не намерено). В данном примере я пытаюсь записать информацию об ошибке в не существующий файл.

```Python
def process_value(value):
    try:
        result = 10 / value
    except ZeroDivisionError as e:
        print("Деление на ноль, обрабатываю...")
        file = open('non_existent_folder/error_log.txt', 'a')
        file.write(f"Произошла ошибка: {e}\n")
        file.close()
    else:
        return result

process_value(0)
```

И получаю в консоли:

```Python
Деление на ноль, обрабатываю...
Traceback (most recent call last):
  File "/home/.../test.py", line 112, in process_value
    result = 10 / value
             ~~~^~~~~~~
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/.../test.py", line 119, in <module>
    process_value(0)
  File "/home/.../test.py", line 115, in process_value
    file = open('non_existent_folder/error_log.txt', 'a')
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'non_existent_folder/error_log.txt'

Process finished with exit code 1
```

В выводе мы видим две ошибки - деление на ноль и файл не найден. При этом их связывает строка **During handling of the above exception, another exception occurred** - Во время обработки вышеуказанного исключения произошло еще одно исключение.

То есть мы видим первое исключение - деление на ноль, только в качестве контекста ко второму. И именно в атрибут с таким названием (`**__context__**`) оно будет сохранено для объекта исключения FileNotFoundError.

Немного монструозный код, но просто, чтобы показать, что оно правда там)

```Python
try:
    result = 10 / 0
except ZeroDivisionError:
    try:
        raise FileNotFoundError
    except FileNotFoundError as new_error:
        print(new_error.__context__)

# Вывод:
division by zero
```

  

Первый же случай, это когда мы намерено вызываем новое исключение во время обработки предыдущего. Забегая немножко вперёд, посмотрим на вызов пользовательского исключения.

```Python
class CreateUserError(Exception):
    """Исключение возникает при ошибке создания пользователя"""

def set_name(name):
    if not isinstance(name, str):
            raise ValueError('Имя должно быть строкой')
    ...
    # логика по установке имени

# часть логики создания пользователя
try:
    set_name(42)
except ValueError as e:
    raise CreateUserError('Пользователь не был создан') from e
```

В этом примере мы также увидим оба исключения в консоли:

```Python
Traceback (most recent call last):
  File "/home/.../test.py", line 161, in <module>
    set_name(42)
  File "/home/.../test.py", line 158, in set_name
    raise ValueError('Имя должно быть строкой')
ValueError: Имя должно быть строкой

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/.../test.py", line 163, in <module>
    raise CreateUserError('Пользователь не был создан') from e
CreateUserError: Пользователь не был создан

Process finished with exit code 1
```

Здесь нужно обратить внимание на несколько вещей:

- Мы использовали инструкцию **raise** в связке с ключевым словом **from**.
    
    `raise CreateUserError('Пользователь не был создан') from e`
    
- Связывающее предложение в traceback также изменилось - **The above exception was the direct cause of the following exception** - Вышеуказанное исключение стало непосредственной причиной следующего исключения.
- У объекта кастомного исключения **CreateUserError** в атрибуте `__cause__` появилась ссылка на объект исключения **ValueError.**
    
    ```Python
    ...
    try:
        set_name(42)
    except ValueError as e:
        try:
            raise CreateUserError('Пользователь не был создан') from e
        except CreateUserError as new_error:
            print(new_error.__cause__)
            
    # Вывод:
    Имя должно быть строкой
    ```
    
- Также у объекта исключения есть атрибут `__suppress_context__`, который по умолчанию False, но при использовании конструкции `raise…from…` меняется на True. И именно он отвечает за подавление контекста) То есть фактически сейчас для объекта CreateUserError заданы два атрибута - context и cause, но мы видим в выводе traceback только один - cause.
    
    ```Python
    ...
    try:
        set_name(42)
    except ValueError as e:
        try:
            raise CreateUserError('Пользователь не был создан') from e
        except CreateUserError as new_error:
            print(new_error.__suppress_context__)
            
    # Вывод
    True
    ```
    

Как должно быть понятно из описания данного случая, нам нужно использовать конструкцию raise…from… намерено, чтобы дать понять, что первое повлекло за собой второе. При этом мы можем дополнить вывод более подробной информацией на каком шаге это произошло.

Ещё нужно рассказать про третий случай) Он уже не про цепочки, но плотно связан с вышерассмотренным. Мы можем использовать конструкцию `raise…from None`!

Интересно, не правда ли?) Как это выглядит и когда нам может понадобиться?)

Да в общем-то в похожей ситуации, когда мы хотим превратить низкоуровневое исключение в более высокоуровневое, но при этом скрыть от пользователя детали реализации (например, если мы пишем библиотеку или серверное приложение, и пользователь в принципе не должен видеть такие нюансы).

```Python
class CreateUserError(Exception):
    """Исключение возникает при ошибке создания пользователя"""

def set_name(name):
    if not isinstance(name, str):
            raise ValueError('Имя должно быть строкой')
    ...
    # логика по установке имени

# часть логики создания пользователя
try:
    set_name(42)
except ValueError as e:
    raise CreateUserError(f'Пользователь не был создан - {e}') from None
    
# Вывод:
Traceback (most recent call last):
  File "/home/.../test.py", line 166, in <module>
    raise CreateUserError(f'Пользователь не был создан - {e}') from None
CreateUserError: Пользователь не был создан - Имя должно быть строкой
```

Что здесь произошло? Дело в том, что в `__context__` в таком случае автоматически попадает объект ValueError, но мы не хотим его отображать. Используя `from None` мы устанавливаем в `__cause__` - None, а `__suppress_context__` автоматически устанавливается в True и подавляет вывод контекстного исключения! Магия рук и никакого мошеничества))

## Классы встроенных исключений

По этому блоку мы пробежимся очень быстро (чтобы не тратить время), буквально посмотрим одним глазком на иерархию исключений, а более подробно вы можете почитать в [документации](https://docs.python.org/3/library/exceptions.html#concrete-exceptions) или посмотреть с примерами в данной [статье](https://medium.com/@sarperismetmakas/python-built-in-exceptions-1f41686155e7#:~:text=In%20Python%2C%20exceptions%20are%20a%20way%20to%20handle%20and%20manage,exceptions%20to%20create%20custom%20exceptions).

```Python
BaseException
 ├── BaseExceptionGroup
 │    └── Группа исключений, содержащая несколько исключений.
 ├── GeneratorExit
 │    └── Исключение при завершении работы генератора.
 ├── KeyboardInterrupt
 │    └── Прерывание программы пользователем (Ctrl + C).
 ├── SystemExit
 │    └── Исключение для завершения программы через sys.exit().
 └── Exception
      ├── ArithmeticError
      │    └── Ошибка арифметической операции.
      │    ├── FloatingPointError
      │    │    └── Ошибка при работе с числами с плавающей запятой.
      │    ├── OverflowError
      │    │    └── Число слишком велико для представления.
      │    └── ZeroDivisionError
      │         └── Деление на ноль.
      ├── AssertionError
      │    └── Ошибка при провале проверки assert.
      ├── AttributeError
      │    └── Попытка доступа к несуществующему атрибуту.
      ├── BufferError
      │    └── Ошибка при работе с буферами.
      ├── EOFError
      │    └── Конец файла, когда ввод неожиданно завершён.
      ├── ExceptionGroup [BaseExceptionGroup]
      │    └── Исключение, содержащее несколько под-исключений.
      ├── ImportError
      │    └── Ошибка при попытке импортировать модуль.
      │    └── ModuleNotFoundError
      │         └── Модуль не найден при импорте.
      ├── LookupError
      │    └── Ошибка при некорректном доступе к коллекции.
      │    ├── IndexError
      │    │    └── Индекс списка выходит за границы.
      │    └── KeyError
      │         └── Ключ не найден в словаре.
      ├── MemoryError
      │    └── Недостаточно памяти для выполнения операции.
      ├── NameError
      │    └── Переменная не определена.
      │    └── UnboundLocalError
      │         └── Локальная переменная используется до присвоения.
      ├── OSError
      │    └── Ошибка операционной системы.
      │    ├── BlockingIOError
      │    │    └── Операция ввода/вывода заблокирована.
      │    ├── ChildProcessError
      │    │    └── Ошибка дочернего процесса.
      │    ├── ConnectionError
      │    │    └── Ошибка соединения.
      │    │    ├── BrokenPipeError
      │    │    │    └── Разрыв канала данных.
      │    │    ├── ConnectionAbortedError
      │    │    │    └── Соединение прервано.
      │    │    ├── ConnectionRefusedError
      │    │    │    └── Соединение отклонено.
      │    │    └── ConnectionResetError
      │    │         └── Соединение сброшено.
      │    ├── FileExistsError
      │    │    └── Файл уже существует.
      │    ├── FileNotFoundError
      │    │    └── Файл не найден.
      │    ├── InterruptedError
      │    │    └── Системный вызов прерван.
      │    ├── IsADirectoryError
      │    │    └── Ожидался файл, но это директория.
      │    ├── NotADirectoryError
      │    │    └── Ожидалась директория, но это файл.
      │    ├── PermissionError
      │    │    └── Недостаточно прав для выполнения операции.
      │    ├── ProcessLookupError
      │    │    └── Процесс не найден.
      │    └── TimeoutError
      │         └── Превышено время ожидания.
      ├── ReferenceError
      │    └── Попытка доступа к уничтоженной ссылке.
      ├── RuntimeError
      │    └── Общая ошибка во время выполнения программы.
      │    ├── NotImplementedError
      │    │    └── Функционал не реализован.
      │    └── RecursionError
      │         └── Превышена глубина рекурсии.
      ├── StopAsyncIteration
      │    └── Завершение асинхронного итератора.
      ├── StopIteration
      │    └── Завершение итератора.
      ├── SyntaxError
      │    └── Ошибка синтаксиса в коде.
      │    └── IndentationError
      │         └── Ошибка отступов.
      │              └── TabError
      │                   └── Смешение пробелов и табуляций.
      ├── SystemError
      │    └── Внутренняя ошибка интерпретатора Python.
      ├── TypeError
      │    └── Несовместимый тип данных.
      ├── ValueError
      │    └── Неверное значение данных.
      │    └── UnicodeError
      │         └── Ошибка при работе с Unicode.
      │         ├── UnicodeDecodeError
      │         │    └── Ошибка при декодировании Unicode.
      │         ├── UnicodeEncodeError
      │         │    └── Ошибка при кодировании Unicode.
      │         └── UnicodeTranslateError
      │              └── Ошибка при переводе Unicode символов.
      └── Warning
           ├── BytesWarning
           │    └── Предупреждение о проблемах с байтами.
           ├── DeprecationWarning
           │    └── Предупреждение об устаревшем функционале.
           ├── EncodingWarning
           │    └── Предупреждение о кодировке.
           ├── FutureWarning
           │    └── Предупреждение об изменениях в будущем.
           ├── ImportWarning
           │    └── Предупреждение о проблемах с импортом.
           ├── PendingDeprecationWarning
           │    └── Предупреждение о будущей устаревшей функции.
           ├── ResourceWarning
           │    └── Предупреждение о проблемах с ресурсами.
           ├── RuntimeWarning
           │    └── Предупреждение о проблемах во время выполнения.
           ├── SyntaxWarning
           │    └── Предупреждение о проблемах с синтаксисом.
           ├── UnicodeWarning
           │    └── Предупреждение о проблемах с Unicode.
           └── UserWarning
                └── Предупреждение, созданное пользователем.
```

Из интересного здесь - исключение **SyntaxError** не будет перехвачено с помощью `except Exception` или `except`, если ошибка синтаксиса происходит **до** запуска программы, на этапе **разбора кода** (парсинга). То есть, если синтаксическая ошибка находится в самом тексте программы, она выбрасывается ещё до того, как начнётся выполнение, и поэтому не может быть обработана через `try-except`.

Однако если ошибка возникает во время выполнения (например, через `eval()`), то её можно перехватить.

```Python
try:
    eval('x === x')  # Синтаксическая ошибка
except Exception as e:
    print(f"Перехвачено исключение: {e}")

# Вывод:
Перехвачено исключение: invalid syntax (<string>, line 1)
```

## Что внутри у BaseException?

Как мы уже узнали ранее, у объекта базового исключения есть следующие атрибуты:

- `__traceback__` - хранит в себе ссылку на объект traceback, связанный с текущим исключением.
- `__context__` - хранит ссылку на объект исключения, в процессе обработки которого оно возникло.
- `__cause__` - хранит в себе ссылку на объект исключения, которое стало причиной вызова данного исключения.
- `__suppress_context__` - хранит булевое значение. По умолчанию False. Меняется на True при установке значения в атрибут `__cause__`. Отвечает за подавление отображения контекста.

Помимо этого для объекта исключения возможны следующие атрибуты и методы:

- `args` - кортеж с объектами, переданными при создании данного исключения. Базовый класс никак не ограничивает нас в их кол-ве или типах, потому что принимает `*args` в `__init__`
    
    ```Python
    new_error = ValueError('Some message', 'Additional info', 42)
    print(new_error.args)
    
    # Вывод:
    ('Some message', 'Additional info', 42)
    ```
    
    Этот атрибут очень важен, и я расскажу о нём подробнее при описании методов.
    
- `__notes__` - в 3.11 был добавлен данный атрибут (список) и метод, который с ним работает - `add_note(note)`. Наконец-то пришло время узнать, как инструкция **raise** может быть использована без аргументов!)
    
    Метод `add_note()` добавляет строку к списку примечаний в атрибуте `__notes__` (важно, что до момента вызова метода `add_note()` атрибут `__notes__` не существует у объекта). Эти примечания будут автоматически включены в вывод после стандартного сообщения об исключении. Примечания могут содержать любую строковую информацию, которая поможет в понимании причины исключения.
    
    Пример того, как добавляются заметки к исключению для более подробного описания контекста ошибки:
    
    ```Python
    try:
        raise ValueError("Некорректное значение")
    except ValueError as e:
        e.add_note("Проблема с параметром 'age'")
        e.add_note("Допустимый диапазон значений: 18-99")
        raise
        
    # Вывод
    Traceback (most recent call last):
      File "/home/.../test.py", line 218, in <module>
        raise ValueError("Некорректное значение")
    ValueError: Некорректное значение
    Проблема с параметром 'age'
    Допустимый диапазон значений: 18-99
    ```
    
    Основное преимущество - оригинальное исключение сохраняется, а заметки добавляются поверх. Инструкция **raise** в данном случае позволяет нам поднять повторно последнее вызванное исключение.
    
- `with_traceback(`_`tb`_`)` - данный метод позволяет нам вызвать новое исключение, но присвоить ему traceback предыдущего (я так и не смогла придумать в каких случаях оно может быть полезно, но теперь вы знаете, что оно есть)).
    
    ```Python
    class CustomError(Exception):
        """Новый вид пользовательского исключения"""
    
    try:
        raise ValueError("Некорректное значение")
    except ValueError as e:
        new_error = CustomError('Моё исключение')
        new_error.with_traceback(e.__traceback__)
        raise new_error from None
        
    # Вывод
    Traceback (most recent call last):
      File "/home/.../test.py", line 225, in <module>
        raise new_error from None
      File "/home/.../test.py", line 221, in <module>
        raise ValueError("Некорректное значение")
    CustomError: Моё исключение
    ```
    

Следующие методы используют кортеж из args:

- `__str__` - предназначен для создания строкового представления исключения, понятного пользователю. Этот метод напрямую зависит от атрибута `args`. Можно представить, что он реализован примерно следующим образом:
    
    ```Python
    def __str__(self):
        if len(self.args) == 0:
            return ""
        elif len(self.args) == 1:
            return str(self.args[0])
        else:
            return str(self.args)
    ```
    
- `__repr__` - это более техническое представление, которое должно быть однозначным и пригодным для воспроизведения объекта с помощью `eval()`. Также использует атрибут args в своей реализации.
- `__reduce__` - метод, который используется при сериализации/десериализации объекта. Атрибут `args` передается в `__reduce__`, чтобы можно было восстановить исключение при десериализации.

И в следующем блоке мы узнаем как легко их все сломать…)

## Создание пользовательских исключений

Самое первое и важное, что нужно запомнить - всегда наследуемся от класса **Exception** (это прямая рекомендация из документации). Но при этом мы можем создавать иерархии исключений, наподобие той, что есть в самом языке, что может помочь структурировать ошибки в больших проектах. Например:

```Python
class FeatureError(Exception):
    """Глобальная ошибка при работе с фичёй"""


class FeatureCreateError(FeatureError):
    """Ошибка создания фичи"""


class FeatureUpdateError(FeatureError):
    """Ошибка обновления фичи"""
```

Также не рекомендуется наследоваться от нескольких исключений сразу (так как это может вызвать проблемы с памятью).

В самом исключении может не быть вообще никакой реализации (если нас устраивает изначальное поведение исключений), но желательно вместо **pass** указать описание класса исключения.

Если же мы хотим добавить свою логику, вот тут нужно быть осторожнее, потому что есть шанс поломать родительские методы)

Например, мы хотим, чтобы наше исключение содержало сообщение и код ошибки. Пока это выглядит следующим образом, всё в порядке.

```Python
class CustomError(Exception):

    def __init__(self, message, code):
        self.code = code
        self.message = message


error = CustomError("Пользовательское сообщение об ошибке", 42)
raise error

# Вывод:
Traceback (most recent call last):
  File "/home/.../test.py", line 245, in <module>
    raise error
CustomError: ('Пользовательское сообщение об ошибке', 42)
```

При этом важно! Конструктор родительского класса тоже будет вызван (не смотря на то, что мы не вызывали явно `super().__init__(message, code)`) и у нашего исключения инициализируется атрибут `args`, который будет хранить в себе аргументы, которые мы передали в момент создания исключения.

```Python
print(error.args)

# Вывод:
('Пользовательское сообщение об ошибке', 42)
```

Потом мы можем захотеть изменить вывод в консоли, например, следующим образом:

```Python
class CustomError(Exception):

    def __init__(self, message, code):
        self.code = code
        self.message = f'Ошибка: {message} | Код ошибки: {code}'


# Создаем исключение
error = CustomError("Пользовательское сообщение об ошибке", 42)
raise error

# Вывод:
Traceback (most recent call last):
  File "/home/.../test.py", line 256, in <module>
    raise error
CustomError: ('Пользовательское сообщение об ошибке', 42)
```

Хмм… мы расчитывали на другой результат - `Ошибка: Пользовательское сообщение об ошибке | Код ошибки: 42`

Тут мы можем вспомнить про атрибут `args` (от которого зависит метод `__str__`) и что в него-то записывается сообщение ещё до его кастомизации, так ещё и `code` передаётся, хотя он нам там не нужен в общем-то… И можем попытаться сделать что-то вроде такого:

```Python
class CustomError(Exception):

    def __init__(self, message, code):
        self.code = code
        self.message = f'Ошибка: {message} | Код ошибки: {code}'
        super().__init__(self.message)


# Создаем исключение
error = CustomError("Пользовательское сообщение об ошибке", 42)
print(error)

# Вывод:
...
CustomError: Ошибка: Пользовательское сообщение об ошибке | Код ошибки: 42
```

Отлично! То, что мы и хотели) Да? Поздравляю! Мы только что сломали работу методов - repr и reduce))

```Python
print(error.__reduce__())
print(error.__repr__())

# Вывод:
(<class '__main__.CustomError'>, ('Ошибка: Пользовательское сообщение об ошибке | Код ошибки: 42',), {'code': 42, 'message': 'Ошибка: Пользовательское сообщение об ошибке | Код ошибки: 42'})
CustomError('Ошибка: Пользовательское сообщение об ошибке | Код ошибки: 42')
```

Вместо:

```Python
(<class '__main__.CustomError'>, ('Пользовательское сообщение об ошибке', 42), {'code': 42, 'message': 'Пользовательское сообщение об ошибке'})
CustomError('Пользовательское сообщение об ошибке', 42)
```

Напоминаю, что оба этих метода должны помогать нам воссоздать ровно такой же объект, какой был изначально. Но в случае, когда мы вызываем `super().__init__(self.message)` с один аргументом, да ещё и видоизменённым, мы сохраняем только его в `args`, а от него зависит не только `__str__`, но и два этих метода. Самым адекватным способом в данном случае будет переопределить именно `__str__`, а логику формирования кортежа в `args` оставить без изменений.

```Python
class CustomError(Exception):

    def __init__(self, message, code):
        self.code = code
        self.message = message

    def __str__(self):
        return f'Ошибка: {self.message} | Код ошибки: {self.code}'
```

В конце ещё хочу упомянуть, что пользовательские исключения обычно прописывают в отдельных файлах — например, `exceptions.py` или `error.py`. Это хорошая практика, которая позволяет держать все исключения в одном месте, делая их проще для отслеживания и управления в больших проектах.

Также исключения можно логгировать, но это совсем другая история…)

Вот пожалуй и всё, что я хотела рассказать вам про исключения. Надеюсь это было не только интересно, но и полезно. И вы узнали что-то новое для себя.

*Я совсем не затронула тему групп исключений, оставлю её в качестве домашнего задания для пытливых читателей =)

## Список использованной литературы

[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)

[https://docs.python.org/3/tutorial/errors.html#](https://docs.python.org/3/tutorial/errors.html#)

[https://www.labirint.ru/books/732482/](https://www.labirint.ru/books/732482/)

[https://www.litres.ru/book/un-cuy/recepty-python-kollekciya-luchshih-tehnik-programmirovaniya-pdf-epu-70870289/](https://www.litres.ru/book/un-cuy/recepty-python-kollekciya-luchshih-tehnik-programmirovaniya-pdf-epu-70870289/)

[https://www.labirint.ru/books/654838/](https://www.labirint.ru/books/654838/)

[https://docs-python.ru/tutorial/oshibki-iskljuchenija-python/sozdanie-polzovatelskogo-klassa-iskljuchenija/](https://docs-python.ru/tutorial/oshibki-iskljuchenija-python/sozdanie-polzovatelskogo-klassa-iskljuchenija/)

[https://jerrynsh.com/python-exception-handling-patterns-and-best-practices/](https://jerrynsh.com/python-exception-handling-patterns-and-best-practices/)

[https://realpython.com/python-lbyl-vs-eafp/](https://realpython.com/python-lbyl-vs-eafp/)